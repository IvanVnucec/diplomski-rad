\documentclass[times, utf8, diplomski, numeric]{templates/template}
\usepackage{booktabs}
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{url}

% konfiguracija za pseudokod
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    inputencoding = utf8,  % Input encoding
    extendedchars = true,  % Extended ASCII
    literate      =        % Support additional characters
      {ž}{{\v z}}1 {č}{{\v c}}1 {š}{{\v s}}1  
}

\lstset{style=mystyle}

\begin{document}

\sveuciliste{SVEUČILIŠTE U ZAGREBU}
\fakultet{FAKULTET ELEKTROTEHNIKE I RAČUNARSTVA}

\title{Programska podrška sustava za određivanje i upravljanje orijentacijom satelita}

\thesisnumber{2346}

\author{Ivan Vnučec}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. 
\izvornik

\zahvala{Posebno hvala mentoru Josipu Lončaru na razumijevanju, nesebičnoj pomoći i susretljivosti. Da nije bilo tebe Josipe, radio bi Web development. \\
Jednako tako hvala i Karli Sever, bez tvog truda moj softver ne bi imao hardver.}

\tableofcontents

\chapter{Uvod}{
    \section{Mali sateliti}{
        Mali sateliti \engl{Small satellites} su skupina satelita koji su, u usporedbi s konvencionalnim satelitima, uvelike ograničeni prema masi, cijeni, kao i prema vremenu potrebnom da ih se razvije \cite{hrvatskiVojnik}.

        Primjene malih satelita nalazimo u svim granama svemirske industrije: u telekomunikaciji, navigaciji, opservaciji Zemlje, znanstvenim istraživanjima i dr.
        
        Njihova zastupljenost na tržištu raste iz godine u godinu jer pružaju jeftin i brz razvoj uz relativno male tehničke zahtjeve \cite{rastMalihSatelita}. Sve je to izravan rezultat revolucije u elektronici i računarstvu \cite{hrvatskiVojnik}. Primjenom većeg broja malih satelita povezanih u konstelaciju, moguće je primjerice pokriti veću površinu zemlje i tako stvoriti uvijek dostupni internet ili navigacijski sustav.
        
        \subsection{Podjela}{
            Iako postoje više podjela satelita u ovisnosti od izvora do izvora, navest ćemo podjelu prema FAA \engl{Federal Aviation Administration} koja uključuje popis od satelita s najvećom masom pa sve do satelita s najmanjom masom \cite{podjelaPremaMasi}. Podjelu je moguće vidjeti u tablici \ref{tbl:podjelaSatelita}.

            \begin{table}[htb]
            \caption{Podjela malih satelita prema masi}
            \label{tbl:podjelaSatelita}
            \centering
            \begin{tabular}{ll} \toprule
            Naziv kategorije satelita & Masa (kg) \\ \midrule
            Small & 601 - 1200 \\
            Mini & 201 - 600 \\
            Micro & 11 - 200 \\
            Nano & 1.1 - 10 \\
            Pico & 0.09 - 1 \\
            Femto & 0.01 - 0.1 \\ \bottomrule
            \end{tabular}
            \end{table}

            Maleni sateliti teže manje od 1200 kilograma i cijena razvoja im je nešto manja od 30 milijuna GBP (britanskih funti), za izradu i lansiranje je potrebno od 2. do 3. godine. Mini sateliti teže do 600 kilograma i njihov razvoj traje oko 2. godine sa cijenom do 30 milijuna GBP. Micro sateliti imaju masu manju od 200 kilograma i koštaju manje od 10 milijuna GBP. Ispod Micro klase nalaze se Nano sateliti mase do 10 kilograma, te Pico i Femto sateliti mase manje od 1. kilograma \cite{hrvatskiVojnik}. Popularnost malih satelita raste iz godine u godinu što prikazuje graf na slici \ref{fig:lansiranja_po_godini}.

            \begin{figure}[htb]
            \centering
            \includegraphics[width=1.0\textwidth]{images/lansiranja_po_godini.png}
            \caption{Broj lansiranja različitih tipova malih satelita kroz godine \cite{nanosats}.}
            \label{fig:lansiranja_po_godini}
            \end{figure}
        }

            \subsubsection{Cubesat format}{
                Cubesat format malih satelita osmišljen je 1999. godine suradnjom Cal Poly sveučilišta u San Luis Obispu i Stanford sveučilišta. Projekt je imao za zadatak standardizirati Cubesat format i definirati njegove specifikacije. Cubesat format definiran je kao kocka veličine 10 cm $\times$ 10 cm $\times$ 10 cm (oznaka 1U) \cite{fersat}. Danas se mogu kombinirati tri (3U), šest (6U) ili više takvih blokova koji tvore veći Cubesat satelit. 1U, 2U i 3U formati prikazani su na slici \ref{fig:cubesat_format}.

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.7\textwidth]{images/cubesat_format.jpg}
                \caption{Prikaz 1U, 2U i 3U Cubesat formata.}
                \label{fig:cubesat_format}
                \end{figure}

                Netom nakon standardizacije Cubesat formata, 1U format postao je najpopularniji format za razvoj i lansiranje koji je pružao jednostavne funkcije kao što su: fotografiranje Zemlje, telekomunikacija te niz jednostavnijih mjerenja koje se trebaju prenijeti na zemlju \cite{fersat}.
            }
        }

        \subsection{Metode lansiranja}{
            Mali sateliti lansiraju se kao sekundarni teret u posebno izrađenim kavezima u kojima stane nekoliko takvih satelita. Za izbacivanje satelita u svemir koristi se opruga jer mali sateliti često nemaju propulziju. Nakon što je izdan izbacivački signal, mehanička opruga vrši silu na male satelite koji potom klizući šinama izlaze kroz vrata kaveza \cite{fersat}. Prikaz kaveza možemo vidjeti na slici \ref{fig:kavez}.

            \begin{figure}[htb]
            \centering
            \includegraphics[width=0.4\textwidth]{images/kavez.jpg}
            \caption{Lansirni kavez Cubesat satelita \cite{kavez_cite}.}
            \label{fig:kavez}
            \end{figure}

            Let rakete koja nosi primarni i sekundarni teret osmišljen je tako da primarni teret dovede u planiranu orbitu i da ga tamo izbaci. Nakon primarnog tereta izbacuje se i sekundarni teret kao jedan ili više malih satelita. Lansiranja primarnog tereta danas su vrlo česta. Datumi lansiranja i orbita znaju se mjesecima unaprijed tako da korisnici sekundarnog tereta mogu planirati orbitu koju žele. Korisnici sekundarnog tereta mogu birati samo između ponuđenih orbita, ali ne mogu mijenjati orbitu ili datum lansiranja. Cijene lansiranja 1U Cubesat-a kreću se oko 90.000 eura, a za 3U Cubesat oko 200.000 eura. Jedna raketa može u svemir ponijeti 10 ili više Cubesat satelita \cite{fersat}. 

            Poslovanje lansiranja malih satelita organizirano je kroz pružatelje lansirnih usluga \engl{Launch Services Provider - LSP} koji zakupljuju prostor za sekundarni teret od poduzeća koje lansiraju rakete \engl{Launch Logistics Provider - LLP}. Danas postoji više LSP-ova i stranka koja želi lansirati satelit ima mogućnost izbora po cijeni i kvaliteti usluge. Poduzeća koja lansiraju satelite u svemir nalaze se po cijelom svijetu \cite{fersat}. 
            
            Listu nekih pružatelja usluga lansiranja malih satelita moguće je vidjeti u tablici \ref{tbl:pru_lan_uslu}.

            \begin{table}[htb]
            \caption{Lista pružatelja usluga lansiranja malih satelita \cite{fersat}.}
            \label{tbl:pru_lan_uslu}
            \centering
            \begin{tabular}{lll} 
            \toprule
            Ime & Lokacija & Web adresa \\ 
            \midrule
            Innovative Solutions in Space & Nizozemska & \url{www.isispace.nl} \\
            ECM Space & Njemačka & \url{www.ecm-space.de} \\
            UT AeroSpace Studies & Kanada & \url{www.utias-sfl.net} \\
            CubeCab (3U+) & SAD & \url{www.cubecab.com} \\
            Nano Avionics & Litva & \url{https://nanoavionics.com/} \\
            Space Flight (3U+) & SAD & \url{https://spaceflight.com/} \\
            \bottomrule
            \end{tabular}
            \end{table}

            Postupak lansiranja započinje potpisivanjem ugovora pri kojem korisnik usluge odabire jedan od ponuđenih datuma lansiranja i mogućih orbita. Pri potpisivanju ugovora korisnik plaća oko 50\% cijene usluge. Potpisivanje ugovora se događa barem dvanaest mjeseci prije planiranog lansiranja. Tijekom slijedećih dva do šest mjeseca korisnik mora obaviti sva testiranja satelita. Šest mjeseci prije lansiranja, korisnik dobiva potvrdu o mjestu na raketi i plaća dodatnih 20\% ugovorene cijene. Dva mjeseca prije lansiranja, korisnik predaje satelit pružatelju lansirnih usluga koji satelit prevozi do lansirne lokacije. Stigavši na lansirnu lokaciju, korisnik plaća dodatnih 20\% cijene. Konačno, u trenutku lansiranja, korisnik plaća posljednjih 10\% cijene. Ukoliko lansiranje ne uspije nema povrata sredstava. Spomenuto obročno plaćanje ne vrijedi za sve pružatelje lansirnih usluga već neki pružatelji imaju drugačije oblike plaćanja. Nakon uspješnog lansiranja pružatelj lansirnih usluga prati orbitu svakog lansiranog satelita i predaje korisniku informacije o orbiti u kojoj se satelit nalazi \cite{fersat}. 
        
        \subsection{Povijesni pregled misija}{
            \emph{nanosats.eu} baza podataka Nano i Cubesat satelita \cite{nanosats} sadrži preko 2000 podataka o lansiranjima Cubesat satelita od 1998. godine pa sve do danas. Prvo lansiranje Cubesat satelita zbilo se 2003. godine iz grada Plesetska u Rusiji u sklopu \emph{Eurockot Launch Services's Multiple Orbit} misije. Cubesat sateliti koji su pušteni u orbitu bili su sateliti nekoliko tvrtki iz Danske, Japana, Kanade i SAD-a \cite{prva_misija}.

            Nekoliko godina kasnije, točnije 2012. godine, lansirano je 11 Cubesat satelita pomoću rakete Atlas V. To je do tada bio najveći broj istovremeno lansiranih satelita gdje je najveći Cubesat satelit bio 24U formata \cite{najveci_lansirni_broj}.

            Od 2012. godine do danas lansirano je preko 1000 malih satelita što je vidljivo na slici \ref{fig:lansiranja_po_godini}.
        }
    }

    \section{Korisni teret satelita}{
        Korisni teret satelita \engl{payload} je podsustav ili skupina podsustava koji imaju za cilj ispuniti neku zadaću (misiju). Primjerice, ako je cilj satelita fotografiranje Zemljine površine, onda će njegov koristan teret biti sustav za fotografiranje (kamera), ili ako želimo uspostaviti komunikaciju sa satelitom, što je gotovo uvijek slučaj, onda će njegov korisni teret biti sustav za komunikaciju.

        \subsection{Vrste tereta}{
            Ovisno o tipu misije, podsustave je moguće svrstati u nekoliko kategorija:

            \begin{itemize}
                \item Opservacija Zemlje
                \item Komunikacija
                \item Navigacija
                \item Znanost i tehnologija
            \end{itemize}

            \subsection{Važnost kontrolirane orijentacije}{
                Sustavi za opservaciju Zemlje sadrže sklopovlje koje promatra Zemljinu površinu ili atmosferu. Najčešće takav sustav sadrži kameru koja fotografira površinu u odabranom dijelu spektra. Na takvom sustavu osim kamere imamo i objektive velikih uvećanja zbog kojih je potrebno imati mogućnost preciznog usmjeravanja kamere. Također, sustavi za komunikaciju osim sklopovlja za obradu signala sadrže i antene. Kako bi pospješili prijem i odašiljanje, potrebno je precizno usmjeravanje antene satelita prema anteni na Zemlji \cite{sattelitePayload}.

                Osim gore opisanih sustava kojima je važna kontrola orijentacije, navest ćemo još jedan primjer gdje nam je kontrola orijentacije važna. Naime, prilikom izbacivanja satelita iz samog prijevoznog sredstva u svemir, događa se nekontrolirana rotacija satelita \engl{tumbling}. Kako bi satelit zaustavio rotaciju, aktivni sustav za kontrolu orijentacije ulazi u posebni način rada \engl{detumbling} u kojem će zaustaviti nekontroliranu rotaciju. Takav zahvat može potrajati tjednima ili mjesecima, ovisno o tipu satelita \cite{fersat}.
            }
        }
    }
}

\chapter{Opis orijentacije satelita}{
    Kako bi matematički prikazali rotacijsko gibanje satelita, satelit je prvo potrebno modelirati kao kruto tijelo. Mi ćemo u nastavku navesti samo osnovne izraze potrebne za modeliranje satelita, a potpune izraze i izvode moguće je pronaći u popratnoj literaturi \cite{adcsKnjiga}.

    Ako govorimo o orijentaciji, važno je objasniti pojam referentnog sustava \engl{reference plane}. Referentni sustav je skup od 3 međusobno ortogonalnih vektora prema kojima određujemo sve ostale vektore: bilo njihovu orijentaciju, bilo pomak. Jedan možda najpoznatiji primjer takvog referentnog sustava je Kartezijev referentni sustav gdje smo kao referentne vektore izabrali 3 jedinična vektora $\boldsymbol{\overrightarrow{i}}$, $\boldsymbol{\overrightarrow{j}}$ i $\boldsymbol{\overrightarrow{k}}$ prema kojima onda određujemo sve ostale vektore u prostoru. 

    Moguće je imati više referentnih sustava gdje je prelazak iz jednog u drugi referentni sustav ostvaren pomoću transformacija s tzv. rotacijskim matricama (o kojima ćemo govoriti kasnije). Referentne sustave najčešće označavamo kao npr. $\mathcal{F}_a$ ili $\mathcal{F}_b$. Rotacijsku matricu koja određuje orijentaciju $\mathcal{F}_a$ referentnog sustava naspram $\mathcal{F}_b$ referentnog sustava označavamo kao $\boldsymbol{C}_{ab}$.

    Da bi definirali orijentaciju satelita prvo moramo definirati referentne sustave. Prvi referentni sustav kojeg definiramo je tzv. inercijski referentni sustav $\mathcal{F}_G$. U klasičnoj fizici, inercijski sustav označava referentni sustav koji ne posjeduje akceleraciju \cite{inertialFrame}. Drugi referentni sustav kojeg definiramo je tzv. referentni sustav tijela (\emph{body}) $\mathcal{F}_b$ koji je nepomičan s obzirom na gibanje čvrstog tijela (satelita). Orijentacija satelita u referentnom sustavu tijela $\mathcal{F}_b$ naspram inercijskog referentnog sustava $\mathcal{F}_G$ označavamo rotacijskom matricom $\boldsymbol{C}_{bG}$.

    \section{Eulerovi kutovi}{
        Eulerovi kutovi predstavljaju 3 kuta između nekog odabranog vektora i ortogonalnih osi Kartezijevog koordinatnog sustava. Želimo li predstaviti rotaciju iz jednog vektora u drugi, to možemo napraviti na nekoliko načina. Jedan od načina navest ćemo u sljedećem primjeru:

        \begin{enumerate}
            \item Rotacija za kut $\psi$ oko originalne z-osi \engl{yaw}.
            \item Rotacija za kut $\theta$ oko tranzicijske y-osi \engl{pitch}.
            \item Rotacija za kut $\phi$ oko transformirane x-osi \engl{roll}.
        \end{enumerate}

        Uzmemo li za primjer 3 uzastopne rotacije: prve oko originalne z-osi, zatim druge oko tranzicijske y-osi i na kraju treće oko transformirane x-osi dobivamo rotaciju prikazanu na slici ispod: 

        \begin{figure}[htb]
        \centering
        \includegraphics[width=1.0\textwidth]{images/eulerovi_kutovi.jpg}
        \caption{Tri uzastopne rotacije oko z-osi, y-osi i x-osi za kut $\psi$, $\theta$, i $\phi$}
        \label{fig:euler_rotacija}
        \end{figure}
    }

    \section{Kvaternioni}{
        Kvaternion je četvero-dimenzionalni vektor s kojim je moguće opisati orijentaciju tijela. Kvaternion u usporedbi s Eulerovim kutovima posjeduje dvije prednosti (o kojima nešto više u nastavku): prva je da ne posjeduje singularnost, i druga da matematičke relacije modeliranja orijentacije više nisu trigonometrijske već algebarske prirode, što ih dodatno čini pogodnima za računanje.

        Kvaternion u sebi sadrži dvije stvari: glavnu os rotacije \engl{principal axis} $\overrightarrow{\boldsymbol{a}}$ i kut rotacije $\phi$ kao što je vidljivo na slici \ref{fig:principal_axis_rotation}. Zbog toga, razlikujemo vektorski i skalarni dio koje definiramo kao:

        \begin{figure}[htb]
        \centering
        \includegraphics[width=0.2\textwidth]{images/principal_axis_rotation.png}
        \caption{Prikaz rotacije vektora $\boldsymbol{\overline{b}}$ oko glavne osi rotacije $\boldsymbol{\overline{a}}$ za kut $\phi$.}
        \label{fig:principal_axis_rotation}
        \end{figure}

        \begin{equation}
        \label{eq:kvaternion}
        \begin{array}{rcl}
            \boldsymbol\epsilon &  = & \overrightarrow{\boldsymbol{a}}\sin\frac{\phi}{2} = \left[\epsilon_{x} \; \epsilon_{y} \; \epsilon_{z} \right], \\
            \eta & = & \cos\frac{\phi}{2}
        \end{array}
        \end{equation}

        U praksi postoje dvije interpretacije kvaterniona u ovisnosti o tome je li skalarni dio prvi element kvaterniona ili posljednji. U našem radu pretpostavit ćemo oblik kvaterniona gdje je skalarni dio prvi, a vektorski drugi:

        \begin{equation}
        \label{eq:kvaternion_elem}
            \boldsymbol{q}=
            \left[\eta \; \boldsymbol\epsilon \right] = \left[q_{1} \; q_{2} \; q_{3} \; q_{4}\right]
        \end{equation}
    }

    \section{Rotacijska matrica}{
        Rotacijska matrica opisuje transformaciju vektora iz originalnog u rotirani za neku poznatu rotaciju. U nastavku ćemo navesti rotacijske matrice koje određujemo pomoću Eulerovih kutova i pomoću kvaterniona i za svaku ćemo dati primjer rotacije vektora.

        \subsection{Prikaz pomoću Eulerovih kutova}{
            Prije nego što ćemo navesti prikaz rotacijske matrice pomoću Eulerovih kutova prvo ćemo navesti kako izgledaju rotacijske matrice kada rotiramo vektore samo oko glavnih osi, a zatim ćemo navesti izraz rotacijske matrice za tzv. 3-2-1 uzastopnu rotacijsku sekvencu.

            \subsubsection{Rotacije oko glavnih osi}{
                Bez ulaženja u detalje, navest ćemo redom kako izgledaju rotacijske matrice za rotacije oko z, y i x osi. Grafičke prikaze tih rotacija moguće je vidjeti na slici \ref{fig:principal_rotations}.

                Rotaciju oko z-osi definiramo kao:

                \begin{equation}
                \label{eq:principal_rot_z}
                \boldsymbol{C}_{z}(\theta_{z}) = 
                \begin{bmatrix}
                    \cos\theta_{z}   & \sin\theta_{z}    &  0 \\
                    -\sin\theta_{z}  & \cos\theta_{z}    &  0 \\
                    0                & 0                 &  1
                \end{bmatrix}
                .
                \end{equation}

                Rotacija oko y-osi:

                \begin{equation}
                \label{eq:principal_rot_y}
                \boldsymbol{C}_{y}(\theta_{y}) = 
                \begin{bmatrix}
                    \cos\theta_{y}   &    0    &  -\sin\theta_{y} \\
                    0                &    1    &  0               \\
                    \sin\theta_{y}   &    0    &  \cos\theta_{y}
                \end{bmatrix}
                .
                \end{equation}

                Rotacija oko x-osi:

                \begin{equation}
                \label{eq:principal_rot_x}
                \boldsymbol{C}_{x}(\theta_{x}) = 
                \begin{bmatrix}
                    1    &      0           &  0 \\
                    0    & \cos\theta_{x}   &  \sin\theta_{x} \\
                    0    & -\sin\theta_{x}  &  \cos\theta_{x}
                \end{bmatrix}
                .
                \end{equation}

                \begin{figure}[htb]
                \centering
                \includegraphics[width=1.0\textwidth]{images/principal_rotations.png}
                \caption{Prikaz rotacija oko glavnih osi.}
                \label{fig:principal_rotations}
                \end{figure}
            }

            \subsubsection{3-2-1 rotacijska sekvenca}{
                Rotacijska sekvenca koja je jako česta u zrakoplovno-svemirskoj industriji označava se kao 3-2-1 orijentacijska sekvenca \engl{3-2-1 attitude sequence}. Takvo ime je uzeto zato što je prva rotacija oko originalne z-osi (oznaka 3), zatim slijedi rotacija oko tranzicijske y-osi (oznaka 2) i na kraju rotacija oko transformirane x-osi (oznaka 1).

                3-2-1 rotacijsku matricu moguće je prikazati pomoću Eulerovih kutova kao:

                \begin{equation}
                \label{eq:euler_rot_mat}
                \begin{array}{rcl}
                \boldsymbol{C}_{21}(\phi, \theta, \psi) & = & \boldsymbol{C}_{x}(\phi) \boldsymbol{C}_{y}(\theta) \boldsymbol{C}_{z}(\psi) \\
                & = &
                \begin{bmatrix}
                    c_{\theta}c_{\psi}                            & c_{\theta}s_{\psi}                            & -s_{\theta} \\
                    s_{\phi}s_{\theta}c_{\psi} - c_{\phi}s_{\psi} & s_{\phi}s_{\theta}s_{\psi} + c_{\phi}c_{\psi} & s_{\phi}c_{\theta} \\
                    c_{\phi}s_{\theta}c_{\psi} + s_{\phi}s_{\psi} & c_{\phi}s_{\theta}s_{\psi} - s_{\phi}c_{\psi} & c_{\phi}c_{\theta}
                \end{bmatrix}
                \end{array}
                ,
                \end{equation}

                gdje radi preglednosti pišemo $s_{b}=\sin(b)$ i $c_{b}=\sin(b)$.

                Primijetimo kako smo 3-2-1 rotacijsku matricu dobili tako što smo izmnožili pojedinačne rotacijske matrice oko glavnih osi (vidi jednadžbe \ref{eq:principal_rot_z}, \ref{eq:principal_rot_y} i \ref{eq:principal_rot_x}). Važno je napomenuti kako u slučaju rotacija ne vrijedi komutativnost i da je redoslijed umnoška matrica vrlo bitan.
            }

            \subsubsection{Singularnost Eulerovih kutova}{
            \label{subsubsection:singularnost_eulerovih_kutova}
                Spomenuta mana reprezentacije rotacije pomoću Eulerovih kutova je tzv. singularnost. Može se pokazati da za svaku parametrizaciju rotacije može doći do singulariteta. Za primjer 3-2-1 sekvence, singularitet nastaje onda kada je kut $\theta=\pm90^{\circ}$. Za takav slučaj rotacijska matrica postaje:

                \begin{equation}
                \boldsymbol{C}_{21}(\phi, 90^{\circ}, \psi) =
                \begin{bmatrix}
                    0                 & 0                  & -1 \\
                    \sin(\phi - \psi) & \cos(\phi - \psi)  &  0 \\
                    \cos(\phi - \psi) & -\sin(\phi - \psi) &  0
                \end{bmatrix}
                .
                \end{equation}

                Fizikalno zbog singulariteta, prva i treća rotacija 3-2-1 sekvence odvijaju se oko jedne te iste osi. U tom slučaju tzv. \emph{roll} i \emph{yaw} kutevi ($\phi$ i $\psi$) su zapravo jednaki kutovi i nije ih moguće jednoznačno odrediti (vidi sljedeće poglavlje). Izvan singulariteta je moguće jednoznačno odrediti sva tri Eulerova kuta. 
            }

            \subsubsection{Određivanje Eulerovih kutova iz rotacijske matrice}{
                Ako rotacijsku matricu označimo kao:

                \begin{equation}
                \label{eq:rotation_matrix}
                \boldsymbol{C} =
                \begin{bmatrix}
                    c_{11} & c_{12} & c_{13} \\
                    c_{21} & c_{22} & c_{23} \\
                    c_{31} & c_{32} & c_{33} \\
                \end{bmatrix}
                ,
                \end{equation}

                iz jednadžbe \ref{eq:euler_rot_mat} moguće je odrediti Eulerove kutove kao:

                \begin{equation}
                \begin{array}{rcl}
                    \phi   & = & \tan^{-1}(c_{23}/c_{33}),\\
                    \theta & = & -\sin^{-1}(c_{13}),\\
                    \psi   & = & \tan^{-1}(c_{12}/c_{11}).
                \end{array}
                \end{equation}
            }

            \textbf{Naglašavamo kako je iznimno važno da prilikom definiranja rotacije pomoću Eulerovih kutova naglasimo o kojoj sekvenci rotacije se radi (npr. 3-2-1) jer rotacijske sekvence ne komutiraju!}
        }

        \subsection{Prikaz pomoću kvaterniona}{
            Rotacijsku matricu pomoću kvaterniona označavamo kao:

            \begin{equation}
                \boldsymbol{C} = (2\eta^2-1)\boldsymbol{1} + 2\boldsymbol\epsilon\boldsymbol\epsilon^{T}-2\eta\boldsymbol\epsilon^{\times},
            \label{eq:quat_rot_matrix}
            \end{equation}

            gdje je $\boldsymbol\epsilon^{\times}$ definiran kao:

            \begin{equation}
                \boldsymbol\epsilon^{\times} =
                \begin{bmatrix}
                    0 & -\epsilon_{z} & \epsilon_{y} \\
                    \epsilon_{z} & 0 & -\epsilon_{x} \\
                    -\epsilon_{y} & \epsilon_{x} & 0 \\
                \end{bmatrix}
                .
            \end{equation}

            Napominjemo da prilikom računanja rotacijske matrice kvaternion $\boldsymbol{q}$ prvo normaliziramo na jediničnu duljinu jer tako garantiramo da kasnije množenje rotacijske matrice i vektora neće rezultirati promjenom duljine vektora već samo promjenu smjera. Kvaternion normaliziramo na sljedeći način:

            \begin{equation}
                \boldsymbol{q}_{norm} = \frac{\boldsymbol{q}}{||\boldsymbol{q}||} = \frac{\boldsymbol{q}}{\sqrt{q_1^2 + q_2^2 + q_3^2 + q_4^2}}
            \end{equation}

            Ako li raspišemo rotacijsku matricu definiranu u jednadžbi \ref{eq:kvaternion_elem} dobivamo izraz \cite{uvod_u_svemirske} koji je pogodniji za računanje:

            \begin{equation}
                \boldsymbol{C} =
                \begin{bmatrix}
                    q_1^2 + q_2^2 - q_3^2 - q_4^2 & 2(q_2q_3 + q_1q_4) & 2(q_2q_4 - q_1q_3) \\
                    2(q_2q_3 - q_1q_4) & q_1^2 - q_2^2 + q_3^2 - q_4^2 & 2(q_3q_4 + q_1q_2) \\
                    2(q_2q_4 + q_1q_3) & 2(q_3q_4 - q_1q_2) & q_1^2 - q_2^2 - q_3^2 + q_4^2 
                \end{bmatrix}
            \label{eq:rot_mat_quat}
            \end{equation}

            \subsubsection{Određivanje kvaterniona iz rotacijske matrice}{
                Pomoću rotacijske matrice definirane u jednadžbi \ref{eq:rotation_matrix} moguće je odrediti sva 4 člana kvaterniona. Prvo određujemo skalarni član kao:

                \begin{equation}
                    \eta = \pm\frac{(\text{trace}[\boldsymbol{C}] + 1)^{\frac{1}{2}}}{2}.
                \end{equation}

                Predznak skalarnog člana nije bitan jer on fizikalno samo označava smjer rotacije. Pozitivan ili negativan predznak daju istu rotaciju.

                Jednom kada smo odredili skalarni član $\eta$, moguće je odrediti vektor $\boldsymbol\epsilon$. Može se pokazati da za $\eta \neq 0$ vrijedi:

                \begin{equation}
                \begin{array}{rcl}
                    \epsilon_{x} & = & \frac{c_{23} - c_{32}}{4\eta}, \\
                    \epsilon_{y} & = & \frac{c_{31} - c_{13}}{4\eta}, \\
                    \epsilon_{z} & = & \frac{c_{12} - c_{21}}{4\eta}.
                \end{array}
                \end{equation}

                Za slučaj kada je $\eta=0$, vrijedi da je kut zakretanja jednak $\phi=\pm\pi$. Može se pokazati kako je moguće izračunati elemente $\boldsymbol\epsilon$ vektora kao:

                \begin{equation}
                \begin{array}{rcl}
                    |\epsilon_{x}| & = & (\frac{c_{11} + 1}{2})^{\frac{1}{2}}, \\
                    |\epsilon_{y}| & = & (\frac{c_{22} + 1}{2})^{\frac{1}{2}}, \\
                    |\epsilon_{z}| & = & (\frac{c_{33} + 1}{2})^{\frac{1}{2}}.
                \end{array}
                \end{equation}

                Za odabir predznaka svakog elementa $\boldsymbol\epsilon$ vektora čitatelja se savjetuje da pogleda u izvor \cite{adcsKnjiga}.
            }
        }

        \subsection{Rotacija vektora pomoću rotacijske matrice}{
            U nastavku ćemo navesti izraze za rotaciju vektora pomoću rotacijskih matrica. Prvi primjer odnosi se na rotaciju vektora oko z-osi, a drugi primjer odnosi se na 3-2-1 rotaciju. Naglašavamo kako će rotacije biti izvedene u istom referentnom sustavu i nećemo se baviti transformacijama iz jednog u drugi referentni sustav. Za potrebe transformacija referentnih sustava čitatelj se upućuje na izvor \cite{adcsKnjiga}.

            \subsubsection{Rotacija oko z-osi}{
                Želimo li vektor $\overrightarrow{\boldsymbol{v}}=\left[ x \; y \; z \right]^T$ rotirati oko z-osi za npr. 30 stupnjeva, prvo računamo rotacijsku matricu pomoću jednadžbe \ref{eq:principal_rot_z}:

                \begin{equation}
                \boldsymbol{C}_{z}(30^{\circ}) = 
                \begin{bmatrix}
                    \cos30^{\circ}   & \sin30^{\circ}    &  0 \\
                    -\sin30^{\circ}  & \cos30^{\circ}    &  0 \\
                    0                & 0                 &  1
                \end{bmatrix}
                ,
                \end{equation}

                zatim pomnožimo vektor $\overrightarrow{\boldsymbol{v}}$ i matricu $\boldsymbol{C}_{z}$ gdje dobivamo rotirani vektor $\overrightarrow{\boldsymbol{v}}'$:

                \begin{equation}
                \begin{array}{rcl}
                    \overrightarrow{\boldsymbol{v}}' & = & \boldsymbol{C}_{z}(30^{\circ}) \overrightarrow{\boldsymbol{v}} \\
                    & = &
                \begin{bmatrix}
                    \cos30^{\circ}   & \sin30^{\circ}    &  0 \\
                    -\sin30^{\circ}  & \cos30^{\circ}    &  0 \\
                    0                & 0                 &  1
                \end{bmatrix}
                \begin{bmatrix}
                    x \\
                    y \\
                    z
                \end{bmatrix}
                \end{array}
                .
                \end{equation}
            }

            \subsubsection{3-2-1 rotacija}{
                Želimo li vektor $\overrightarrow{\boldsymbol{v}}$ definiran u prošlom primjeru rotirati prvo oko z-osi za 30 stupnjeva, zatim oko tranzicijske y-osi za 20 stupnjeva i na kraju oko transformirane x-osi za 10 stupnjeva, prvo računamo rotacijsku matricu pomoću jednadžbe \ref{eq:euler_rot_mat} kao:

                \begin{equation}
                \boldsymbol{C}_{21}(10^\circ, 20^\circ, 30^\circ) = \boldsymbol{C}_{x}(10^\circ) \boldsymbol{C}_{y}(20^\circ) \boldsymbol{C}_{z}(30^\circ),
                \end{equation}

                zatim pomnožimo vektor $\overrightarrow{\boldsymbol{v}}$ i matricu $\boldsymbol{C}_{21}$ gdje dobivamo rotirani vektor $\overrightarrow{\boldsymbol{v}}'$:

                \begin{equation}
                    \overrightarrow{\boldsymbol{v}}' = \boldsymbol{C}_{21}(10^\circ, 20^\circ, 30^\circ) \overrightarrow{\boldsymbol{v}}.
                \end{equation}
            }
        }
    }

    \section{Jednadžba rotacijskog gibanja}{
        Želimo li definirati jednadžbe rotacije satelita, važno se je prvo prisjetiti definicija referentnog sustava tijela $\mathcal{F}_b$ i inercijskog referentnog sustava $\mathcal{F}_G$. Orijentaciju između ta dva referentna sustava moguće je opisati orijentacijskom matricom $\boldsymbol{C}_{bG}$ i to na barem dva načina: pomoću Eulerovih kutova ili pomoću kvaterniona (vidi prethodna poglavlja).

        Kako je $\mathcal{F}_b$ referentni sustav nepomičan s obzirom na tijelo satelita, kutnu brzinu referentnog sustava tijela $\mathcal{F}_b$ s obzirom na $\mathcal{F}_G$ inercijskog referentnog sustava označavamo kao:

        \begin{equation}
            \boldsymbol{\omega}_{bG} = \left[ \omega_1 \; \omega_2 \; \omega_2\right]^T.
        \end{equation}

        \subsection{Prikaz pomoću Eulerovih kutova}{
            Jednadžbu rotacijskog gibanja pomoću Eulerovih kutova definiramo kao:

            \begin{equation}
                \begin{bmatrix}
                    \dot{\phi} \\
                    \dot{\theta} \\
                    \dot{\psi}
                \end{bmatrix}
                =
                \begin{bmatrix}
                    1 & \sin\phi\tan\theta & \cos\phi\tan\theta \\
                    0 & \cos\phi & -\sin\phi \\
                    0 & \sin\phi\sec\theta & \cos\phi\sec\theta
                \end{bmatrix}
                \boldsymbol{\omega}_{bG}.
            \end{equation}
        }

        \subsection{Prikaz pomoću kvaterniona}{
            Jednadžbu rotacijskog gibanja pomoću kvaterniona i kutne brzine definiramo kao:

            \begin{equation}
            \label{eq:rot_gib}
            \begin{array}{rcl}
                \dot{\boldsymbol\epsilon} &  = & \frac{1}{2}(\eta\boldsymbol{1} + \boldsymbol{\epsilon}^\times)\boldsymbol{\omega}_{bG}, \\
                & & \\
                \dot{\eta} & = & -\frac{1}{2}\boldsymbol{\epsilon}^T\boldsymbol{\omega}_{bG}.
            \end{array}
            \end{equation}

            Radi lakšeg računanja, raspišemo li jednadžbu \ref{eq:rot_gib} pomoću definicije kvaterniona u jednadžbi \ref{eq:kvaternion_elem} dobiti ćemo relaciju za rotacijsko gibanje \cite{uvod_u_svemirske} kao:

            \begin{equation}
            \label{eq:rot_qib_elem}
                \dot{\boldsymbol{q}} = \frac{1}{2} \boldsymbol{S}(\boldsymbol{\omega}_{bG}) \boldsymbol{q}
            \end{equation}

            gdje je matrica $\boldsymbol{S}(\boldsymbol{\omega}_{bG})$ definirana kao:

            \begin{equation}
                \boldsymbol{S}(\boldsymbol{\omega}_{bG}) =
                \begin{bmatrix}
                    0        & -\omega_1    & -\omega_2 & -\omega_3 \\
                    \omega_1 &     0        & \omega_3  & -\omega_2 \\
                    \omega_2 & -\omega_3    &    0      & \omega_1 \\
                    \omega_3 & \omega_2     & -\omega_1 &     0 
                \end{bmatrix}
                .
            \end{equation}
        }
    }

    \section{Usporedba Eulerovih kutova i kvaterniona}{
        Kao što smo već pisali u poglavlju \ref{subsubsection:singularnost_eulerovih_kutova}, dva su problema prikazivanja orijentacije pomoću Eulerovih kutova. Prvi problem je singularitet gdje za neke kutove koje reprezentiraju istu orijentaciju nije moguće jednoznačno odrediti Eulerove kutove iz rotacijske matrice. Drugi problem je što za opisivanje orijentacije koristimo trigonometrijske funkcije koje je kompleksnije izračunati na računalima.

        Prikaz orijentacije kvaternionom rješava nas problema singulariteta zbog dodatnog četvrtog člana. Kvaternionom smo također riješili problem računanja trigonometrijskih funkcija jer jednadžbe više ne sadrže trigonometrijske funkcije nego obične algebarske izraze.

        S druge strane, pozitivna strana prikaza orijentacije pomoću Eulerovih kutova je njihova intuitivnost jer svaki Eulerov kut označava kut rotacije oko pojedine osi. Informacija o orijentaciji kod kvaterniona skrivena je unutar kombinacije skalarnog i vektorskog člana i na prvi pogled izgleda nelogično. Skalarni član ne označava izravno kut zakreta oko osi rotacije već njegov kosinus kuta, a vektorski dio sadrži skaliranu os rotacije sinusom kuta rotacije (vidi jednadžbu \ref{eq:kvaternion}).
    }

    \section{Pojednostavljeni model satelita}{
    \label{section:pojednostavljeni_model_satelita}
        Radi jednostavnosti prilikom razvijanja programske podrške fokusirali smo se na određivanje i kontrolu orijentacije oko samo jedne osi. 

        Model kutne brzine oko jedne osi u Laplaceovoj domeni definiramo kao sustav prvog reda:

        \begin{equation}
        \label{eq:laplace_prvi_red}
        H(s) = \frac{Y(s)}{X(s)} = K \frac{1/\tau}{s + 1/\tau},
        \end{equation}

        gdje su $K$ i $\tau$ koeficijenti prijenosne funkcije. Parametar $K$ mogli bi okarakterizirati kao koeficijent pretvorbe mjernih jedinica ulaza $X(s)$ i izlaza $Y(s)$, a parametar $\tau$ kao koeficijent tromosti sustava (vremenska ovisnost).

        Drugi pojednostavljeni model sustava opisuje nam orijentaciju satelita oko jedne osi (kut) i dobili smo ga integriranjem jednadžbe \ref{eq:laplace_prvi_red} za model kutne brzine satelita. Model orijentacije u Laplaceovoj domeni definiramo kao:

        \begin{equation}
        \label{eq:laplace_drugi_red}
            E(s) = H(s) \; \frac{1}{s} = K \frac{1/\tau}{s + 1/\tau} \; \frac{1}{s}.
        \end{equation}

        Primijetimo kako je model orijentacije satelita oko jedne osi sustav drugog reda.
    }
}

% TODO Provjeri sve jednadzbe
% TODO Vidi kako citirat linkove i doradi ih

\chapter{Sustav za određivanje i upravljanje orijentacijom satelita (ADCS)}{
    U ovom poglavlju navest ćemo definiciju ADCS \engl{Attitude Determination and Control system} sustava. Navest ćemo osnovne dijelove sustava. Navest ćemo najčešće korištene senzore i aktuatore, objasniti njihove karakteristike i navesti prednosti i mane. Također ćemo opisati metode i algoritme za određivanje i kontrolu orijentacije. Na koncu ćemo opisati razvijeno sklopovlje i navesti odabrane senzore i aktuatore. 

    \section{Uvod}{
        ADCS sustav je sustav koji određuje orijentaciju satelita pomoću podataka iz senzora na temelju kojih sustav aktuatorima vrši korekciju orijentacije u željeni položaj i tu orijentaciju održava. 

        \subsection{Određivanje i upravljanje orijentacijom}{
            Senzori koje koristi ADCS sustav za određivanje orijentacije najčešće ne daju direktno podatak o orijentaciji već se orijentacija određuje (estimira) pomoću tzv. estimacijskih algoritama. Problem senzora općenito je njihova neodređenost koja onda doprinosi grešci estimaciji orijentacije. Zbog neodređenosti senzora razvijeni su estimacijski algoritmi koje uzimaju u obzir neodređenost senzora i tako smanjuju neodređenost estimirane orijentacije.

            Jednom kada smo odredili orijentaciju i ako ona nije jednaka željenoj, slijedi postupak korekcije (kontrole). Postupak korekcije započinje računanjem razlike željene i trenutno estimirane orijentacije. Regulator orijentacije pomoću te razlike izračunava optimalnu korekciju koju je potrebno izvršiti kako bi došli u željenu orijentaciju. Korekciju orijentacije izvršavaju mehanički ili električni aktuatori. Aktuatori stvaraju korekcijski moment koji satelit na koncu dovode u željenu orijentaciju. Postignuvši željenu orijentaciju, ADCS sustav će je nastojat održavati.

            Opisana estimacija i kontrola orijentacije ADCS sustava događa se u stvarnom vremenu kroz cijeli misiju satelita. Ni u jednom trenu se ne smije dogoditi da satelit posjeduje neželjenu ili nekontroliranu orijentaciju jer to može značiti kraj misije.
        }

        \subsection{Važnost ADCS sustava}{
            NASA-ino istraživanje pokazalo je da je ADCS sustav zaslužan za 23\% pogrešaka na navigacijsko-kontrolnim sustavima \engl{Guidance, Navigation and Control - GN\&C}, i da je velika većina tih anomalija u konačnici uzrokovala kraj misije \cite{greskeNaAdcsPostotak}. U nastavku ćemo navesti jedan primjer greške na ADCS sustavu.

            Naime, svemirska letjelica \emph{Lewis} \cite{lewis} lansirana je 1997. godine s predviđenim trajanjem misije od 5 godina. Nakon postizanja uspješne orbite, satelit je započeo s normalnim radom i nije ga više bilo potrebno aktivno kontrolirati. U normalnom radu solarni paneli su bili upereni prema Suncu kako bi prikupili maksimalnu količinu električne energije. Zbog greške prilikom rada na jednom od aktuatora, stvarao se je neprimjetno mali konstantni moment oko jedne osi koju senzori nisu mogli detektirati. Nakon nekoliko dana neprestane rotacije satelit se je počeo nekontrolirano rotirati i solarni paneli s vremenom nisu prikupili dovoljno energije. Jednom kada su inženjeri napokon uočili nekontroliranu rotaciju već je bilo prekasno jer se je baterija satelita potpuno ispraznila i komunikacija sa satelitom zauvijek prekinuta \cite{greskeNaAdcsSlucajevi}.
        }
    }

    \section{Osnovni dijelovi}{
        Generalno, osnovni dijelovi ADCS sustava su: računalo, senzori i aktuatori. U nastavku ćemo zasebno opisati svaki dio i navesti neke karakteristike.
 
        \subsection{Računalo}{
            Računalo je zaslužno za prikupljanje i obradu podataka koje dolaze sa senzora i za kontrolu aktuatora. Prikupljanje podataka sa senzora vrši se preko komunikacijskih kanala (sabirnica). Obrada podataka zasniva se na računanju zahtjevnih estimacijskih algoritama koji na koncu daju podatak o trenutnoj orijentaciji. Na temelju razlike trenutne i željene orijentacije, računalo računa/modulira kontrolni signal koji se dalje šalje aktuatorima preko predviđenih sabirnica. 

            Neki od zahtjeva ADCS računala su: mala potrošnja, otpornost na radijaciju/kozmičke zrake, brzina izvođenja operacija, pouzdanost i dr. Pri odabiru računala važno je ako je računalo već korišteno u nekim prijašnjim misijama.
        }

        \subsection{Senzori orijentacije}{
        \label{subsection:senzori_orijentacije}
            Senzori orijentacije ili orijentacijski senzori elektroničke su naprave iz kojih je moguće dobiti podatak o orijentaciji. Podatak o orijentaciji najčešće ne dolazi direktno sa senzora već se orijentacija estimira matematičkim algoritmima koji kao svoj rezultat daju estimiranu orijentaciju \cite{adcsKnjiga}. Za precizno određivanje orijentacije nekada je potrebno uzeti podatke iz više senzora odjednom. Takav način prikupljanja podataka zovemo engl. \emph{sensor fusion}. U nastavku ćemo navesti najkorištenije senzore, njihove karakteristike i način rada.

            \subsubsection{Senzor Sunca}{
                Senzore Sunca dijelimo u dvije skupine: analogne i digitalne. Analogni senzori Sunca rade na principu solarnih ćelija, a podatak o smjeru tzv. vektora sunca moguće je dobiti iz generirane struje ćelija. Slika \ref{fig:sensor_sunca_industrija} prikazuje industrijsku izvedbu jednog takvog senzora.

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.6\textwidth]{images/sensor_sunca_industrija.jpg}
                \caption{Prikaz industrijske izvedbe senzora Sunca tvrtke Bradford \cite{sunSensorBradford}.}
                \label{fig:sensor_sunca_industrija}
                \end{figure}

                Struja iz solarnih ćelija ovisi o kutu $\theta$ što označava kut između normale senzora $\hat{\overrightarrow{\boldsymbol{n}}}$ i vektora nadolazeće zrake Sunca $\hat{\overrightarrow{\boldsymbol{v}}}$ (vidi sliku \ref{fig:sensor_sunca}). Vezu struje ćelija $i$ i kuta $\theta$ definiramo kao:

                \begin{equation}
                    i(\theta) = i(0)\cos\theta.
                \end{equation}

                Senzor Sunca ima konačni kut gledanja u obliku stošca. Sa samo jednim senzorom Sunca nije moguće jednoznačno odrediti vektor Sunca $\hat{\overrightarrow{\boldsymbol{v}}}$ već se primjenjuje paradigma \emph{sensor fusion}-a gdje dodamo još jedan senzor Sunca (vidi sliku \ref{fig:sensor_sunca_sensor_fusion}) \cite{adcsKnjiga}.

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.3\textwidth]{images/sensor_sunca.png}
                \caption{Prikaz modela senzora Sunca.}
                \label{fig:sensor_sunca}
                \end{figure}

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.55\textwidth]{images/sensor_sunca_sensor_fusion.png}
                \caption{Prikaz para senzora Sunca.}
                \label{fig:sensor_sunca_sensor_fusion}
                \end{figure}
            }

            \subsubsection{Troosni magnetometar}{
            \label{subsubsection:troosni_magnetometar}
                Troosni magnetometar mjeri vektor lokalnog magnetskog polja Zemlje u koordinatnom sustavu senzora. 
                
                Magnetometri su relativno neprecizni senzori i za pouzdanija mjerenja potrebno ih je kalibrirati \cite{adcsKnjiga}. Kalibracija ima za cilj smanjiti utjecaj tzv. engl. \emph{Hard} i \emph{Soft} efekata. Prije nego objasnimo spomenute efekte objasniti ćemo postupak prikupljanja podataka u svrhu kalibracije magnetometra. 

                Kalibracija magnetometra započinje prikupljanjem podataka iz senzora i to tako što ćemo magnetometar rotirati u svim smjerovima pazeći da ne zanemarujemo određen položaj. Nakon što smo prikupili dovoljno podataka, možemo prikazati izmjerene vektore magnetskog polja kao skupinu točaka gdje svaka točka prikazuje vrh vektora očitane vrijednosti magnetskog polja. Prikaz očitanih vrijednosti idealnog magnetometra raspoređeni su po idealnoj sferi radijusa duljine vektora magnetskog polja sa središtem u centru koordinatnog sustava (vidi sliku \ref{fig:mag_ideal}).

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.7\textwidth]{images/mag_ideal.png}
                \caption{Točkasti prikaz mjerenja vektora Zemljinog magnetskog polja pomoću idealnog magnetometra. Vrijednosti mjerenja su u jedinici $\mu T$.}
                \label{fig:mag_ideal}
                \end{figure}

                Nakon što smo opisali postupak prikupljanja podataka, slijedi objašnjenje \emph{Hard} i \emph{Soft} efekata. \emph{Hard} efekt je greška magnetometra koja utječe na mjerenja magnetskog polja i koja se  manifestira kao translacija ishodišta rezultantne sfere mjerenja za neki fiksni vektor (vidi sliku \ref{fig:mag_hard}). Možemo slobodno reći kako su mjerenja pristrana odnosno da imaju tzv. engl. \emph{bias}. Uzrok \emph{Hard} efekta su najčešće stacionarne interferencije magnetskih polja kojeg želimo mjeriti i magnetskih polja okolnih metalnih dijelova. Magnetska interferencija dolazi ili od samog magnetometra ili od okolnog elektroničkog sklopovlja. 

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.7\textwidth]{images/mag_hard.png}
                \caption{Točkasti prikaz mjerenja vektora Zemljinog magnetskog polja pomoću magnetometra s tzv. \emph{Hard} efektom. Vrijednosti mjerenja su u jedinici $\mu T$.}
                \label{fig:mag_hard}
                \end{figure}

                \emph{Soft} efekti nastaju zbog predmeta u neposrednoj blizini magnetometra koji uzrokuju distorziju mjerenog lokalnog magnetskog polja. \emph{Soft} efekt, kolokvijalno rečeno, razvlači i kosi sferu mjerenja koja zatim oblikom postaje nalik nakošenom elipsoidu (vidi sliku \ref{fig:mag_hard_soft}).

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.7\textwidth]{images/mag_hard_soft.png}
                \caption{Točkasti prikaz mjerenja vektora Zemljinog magnetskog polja pomoću magnetometra s tzv. \emph{Hard} i \emph{Soft} efektima. Vrijednosti mjerenja su u jedinici $\mu T$.}
                \label{fig:mag_hard_soft}
                \end{figure}

                Modeliranje spomenutih efekata opisujemo u sljedećoj jednadžbi:

                \begin{equation}
                    (\boldsymbol{x} - \boldsymbol{b}) \boldsymbol{R} (\boldsymbol{x} - \boldsymbol{b})^T = \beta^2,
                \end{equation}

                gdje je $\boldsymbol{R}$ matrica tipa $3\times3$ određuje oblik elipsoida (npr. za sferu jedinična matrica, a za elipsoid pozitivno definitna), vektor $\boldsymbol{b}$ tipa $1\times3$ definira središte elipsoida, a skalar $\beta$ predstavlja duljinu vektora magnetskog polja. 

                Kalibraciju magnetometra vršimo pomoću sljedeće relacije:

                \begin{equation}
                    \boldsymbol{m} = (\boldsymbol{x} - \boldsymbol{b}) \boldsymbol{A},
                \end{equation}

                gdje novo-definirana matrica $\boldsymbol{A}$ tipa $3\times3$ transformira oblik elipsoida u pravilnu sferu (eliminira utjecaj \emph{Soft} efekta), a definirani vektor $\boldsymbol{b}$ translatira elipsoid u ishodište koordinatnog sustava (eliminira utjecaj \emph{Hard} efekta).

                Problem kalibracije magnetometra uključuje problem pronalaska $\boldsymbol{A}$ i $\boldsymbol{b}$ parametara. Parametre je moguće pronaći pomoću \texttt{magcal} funkcije unutar MATLAB alata \cite{magcal}. Kalibraciju magnetometra vršimo u programskom kodu nakon svakog primitka nekalibrirane vrijednosti magnetometra. Programski isječak kalibracije moguće je vidjeti ovdje \cite{kalibracijaMagKod}. Dodatna objašnjenja u vezi kalibracije magnetometra mogu se pronaći ovdje \cite{kalibracijaMatlabStranica}.

                Zbog spomenutih vanjskih utjecaja na vrijednosti mjerenja magnetometra, magnetometar se može fizički udaljiti od izvora smetnji pomoću konstrukcije nazvane engl. \emph{boom} (vidi sliku \ref{fig:boom}) te tako smanjiti pogreške mjerenja \cite{adcsKnjiga}. 

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.5\textwidth]{images/boom.jpg}
                \caption{Prikaz tzv. \emph{boom}-a na čijem vrhu se nalazi magnetometar. Izvor Ørsted misija \cite{boomCite}.}
                \label{fig:boom}
                \end{figure}
            }

            \subsubsection{Pratioci zvijezda \engl{Star Trackers}}{
                Pratioci zvijezda u usporedbi sa ostalim senzorima pružaju najpreciznija mjerenja orijentacije iz dva razloga: prvi je što su svjetlosni izvori zvijezda točkaste prirode i tako pružaju precizna mjerenja, i drugi, što se zvijezde zbog svoje udaljenosti od senzora doimaju kao stacionarni izvori neovisno o položaju satelita unutar orbite.

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.5\textwidth]{images/star_tracker.png}
                \caption{Prikaz tzv. \emph{boom}-a na čijem vrhu se nalazi magnetometar. Izvor Redwire \cite{starTrackerCite}.}
                \label{fig:star_tracker}
                \end{figure}

                Pomoću pratioca zvijezda moguće je pratiti vektor smjera samo jedne zvijezde i tako, u ovisnosti o položaju senzora na satelitu, orijentacijskom matricom dobiti podatak smjera zvijezde u referentnom sustavu satelita. Uporabom podataka iz ostalih senzora (\emph{sensor fusion}) moguće je jednoznačno odrediti orijentaciju satelita. 

                U praksi pratioci zvijezda prate više zvijezda odjednom ne bi li smanjili neodređenost orijentacije. Jednom kada je senzor odredio orijentaciju, svako sljedeće mjerenje zasniva se na praćenju istih zvijezda i metodom usrednjavanja moguće je postignuti veću preciznost. Neodređenost je dodatno moguće smanjiti upotrebom tzv. zvjezdanih kataloga \cite{starCatalogs} koji sadrže podatke o položaju poznatih zvijezda i zviježđa.

                Zbog svega navedenoga, pratioci zvijezda su najprecizniji senzori orijentacije od svih do sad navedenih senzora, ali s druge strane i najskuplji, najkompleksniji i najnepouzdaniji senzori \cite{adcsKnjiga}. 
            }
        }

        \subsection{Senzori kutne brzine}{
        \label{subsection:senzori_kutne_brzine}
            Senzori kutne brzine mjere kutnu brzinu referentnog sustava tijela naspram referentnog inercijskog sustava. Kao što ćemo vidjeti u nastavku rada, većina algoritama za procjenu orijentacije koriste podatak o kutnoj brzini satelita kao dodatnu korisnu informaciju. 

            Kutnu brzinu moguće je izračunati kao vremensku derivaciju orijentacije ali takav nam izračun unosi neodređenost u obliku visokofrekventnog (VF) šuma. Senzori kutne brzine nemaju VF izražen šum ali zato imaju problem sa tzv. \emph{bias}-om - niskofrekventnim (NF) šumom. 

            Prednost senzora kutne brzine je što ne zahtijevaju eksterni izvor informacije. Primjerice, senzor Sunca uvijek mora imati prisutno Sunce ne bi li izračunali orijentaciju satelita ili magnetometar koji mora biti u prisutnosti izvora magnetskog polja. 

            U trenucima kada ne možemo direktno dobiti podatak o orijentaciji satelita, integracijom kutne brzine moguće je odrediti orijentaciju. Problem takvog načina određivanja orijentacije je spomenuti \emph{bias} koji uzrokuje integracijsku grešku. Zbog toga se takav način određivanja orijentacije ograničava na kratke vremenske periode u kojima je greška integracije zanemariva.

            Postoji više vrsta senzora kutne brzine, a tradicionalno su najpopularniji tzv. mehanički žiroskopi. Mane mehaničkih žiroskopa su mehanički pokretni dijelovi koji stvaraju vibracije, s vremenom im raste nepouzdanost i za rad koriste relativno puno električne energije. Zbog toga su nedavno u primjenu ušli tzv. laserski žiroskopi koji ne posjeduju pokretne dijelove \cite{adcsKnjiga}. 

            Osim mehaničkih i laserskih žiroskopa, postoje i tzv. \emph{MEMS} žiroskopi koji pomoću tzv. Coriolisovog efekta mjere kutnu brzinu. Takvi senzori najčešće se ugrađuju u integrirane sklopove i u svom radu koriste nanostrukture koje omogućavaju mjerenje Coriolisovog efekta \cite{memsGyro}.
        }

        %TODO Povecaj font na nekim jednadžbama

        \subsection{Aktuatori}{
            Aktuatori su uređaji koji na temelju kontrolnog signala vrše korekciju orijentacije. Dijelimo ih u dvije skupine: oni koji mijenjaju kutnu količinu gibanja satelita i oni koji je ne mijenjaju. Potisnici i magnetorkeri spadaju u prvu skupinu, a zamašnjaci u drugu skupinu \cite{adcsKnjiga}. U nastavku slijedi opis svakog spomenutog aktuatora. 

            \subsubsection{Potisnici \engl{Thrusters}}{
                Potisnici su aktuatori koji rade na principu izbacivanja fluidne mase te tako stvaraju potisnu silu. Ako potisni vektor ne prolazi kroz centar mase satelita, u trenutku izbacivanja mase doći će do stvaranja momenta. Kao što se može vidjeti na slici \ref{fig:thruster_img}, potisnik koji generira silu $F$ na udaljenosti $r$ od centra mase, uzrokuje moment $T$ definiran kao $T=Fr$.

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.5\textwidth]{images/thruster_img.png}
                \caption{Princip rada potisnika.}
                \label{fig:thruster_img}
                \end{figure}

                Potisnik nije u stanju generirati silu $F$ u oba smjera (naravni i suprotni smjer). Zbog toga je za stvaranje pozitivnog i negativnog momenta potrebno imati dva međusobno suprotno orijentirana potisnika. Sukladno tomu, za troosno upravljanje orijentacijom satelita potrebno je imati najmanje 6 potisnika \cite{adcsKnjiga}.
            }

            % TODO Provjeri sve citate i dodaj ako negdje treba dodat
            % TODO Provjeri sve tocke i zareze u svakoj jednadzbi
            % TODO provjeri recenice kod svake slike

            \subsubsection{Magnetorkeri \engl{magnetorquers, magnetic torquers}}{
                Magnetorkeri su aktuatori koji generiraju moment pomoću tzv. magnetske sprege svojstveno-generiranog magnetskog polja i magnetskog polja Zemlje. Magnetorker je u suštini zavojnica namotana oko zračne ili feromagnetske jezgre. 

                Magnetorker počiva na Amperovom zakonu koji kaže da prolaskom struje kroz namotaje zavojnice dolazi do stvaranja magnetskog polja (magnetski dipol). Međusobnom interakcijom generiranog dipola magnetorkera $\overrightarrow{\boldsymbol{m}}$ i magnetskog dipola Zemlje $\overrightarrow{\boldsymbol{b}}$ stvara se moment $\overrightarrow{\boldsymbol{T}}$ jednak:

                \begin{equation}
                    \label{eq:magnetorker_eq}
                    \overrightarrow{\boldsymbol{T}} = \overrightarrow{\boldsymbol{m}} \times \overrightarrow{\boldsymbol{b}}.
                \end{equation}

                Moguće je pokazati kako je vektorski produkt (također vektor) u jednadžbi \ref{eq:magnetorker_eq} uvijek okomit na magnetski dipol Zemlje $\overrightarrow{\boldsymbol{b}}$ i zbog toga je nemoguće generirati moment onda kada je položaj dipola magnetorkera usmjeren jednako kao i dipol magnetskog polja Zemlje.

                Jedan magnetorker omogućuje upravljanje orijentacijom satelita samo u jednoj osi što znači da za troosno upravljanje orijentacijom tipično imamo 3 međusobno ortogonalna magnetorkera (vidi sliku \ref{fig:magnetorquer_img}).

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.7\textwidth]{images/magnetorquer_img.jpg}
                \caption{Magnetorker tvrtke NanoAvionics \cite{magnetorquer_cite}.}
                \label{fig:magnetorquer_img}
                \end{figure}

                Zbog relativno slabe jakosti Zemljinog magnetskog polja, teško je generirati momente dovoljne jakosti, pogotovo za satelite velike momente tromosti. Zbog toga se kontrola orijentacije najčešće vrši pomoću zamašnjaka u sprezi sa magnetorkerima iz dva razloga: prvi razlog je već spomenuta nedovoljna jakost generiranog momenta od strane magnetorkera, a drugi razlog je problem tzv. zasićenja zamašnjaka (vidi kasnije poglavlje).

                Valja skrenuti pažnju i na problem utjecaja magnetorkera na mjerenja senzora magnetskog polja. Ako prilikom vršenja korekcije orijentacije pomoću magnetorkera mjerimo magnetsko polje, doći će do magnetske interferencije magnetorkera i senzora magnetskog polja. Rješenje problema leži u tome da za vrijeme mjerenja magnetskog polja magnetorker ne vrši korekciju orijentacije \cite{adcsKnjiga}.

                U sklopu projekta razvijena je metoda optimalne parametrizacije magnetorkera koja će za dani magnetski moment parametrizirati magnetorker tako da posjeduje minimalnu masu uz minimalni potrošak snage \cite{magnetorker_ieee}.
            }

            \subsubsection{Zamašnjaci \engl{Momentum wheels}}{
                Zamašnjaci su mehanički uređaji koji rade na principu očuvanja kutne količine gibanja. Zamašnjak se sastoji od rotirajuće mase i pogona (elektromotora). Naime, kada elektromotorom vršimo moment u jednom smjeru, zbog zakona očuvanja kutne količine gibanja, zamašnjak će generirati jednak moment po iznosu ali u suprotnom smjeru ne bi li ukupna kutna količina gibanja satelita ostala ista (vidi sliku \ref{fig:zamasnjak_fig}). Na taj način moguće je rotirati satelit u jednu ili u drugu stranu. U nominalnom stanju zamašnjak ne posjeduje kutnu brzinu. Zamašnjaci kao aktuatori predstavljaju najprecizniju kontrolu orijentacije \cite{adcsKnjiga}.

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.7\textwidth]{images/zamasnjak.png}
                \caption{Princip rada zamašnjaka.}
                \label{fig:zamasnjak_fig}
                \end{figure}

                Problem zamašnjaka manifestira se s vremenom. Da bi objasnili problem zamašnjaka, pretpostavimo da satelitu želimo održavati jednaku orijentaciju bez obzira na vanjske parazitne momente/smetnje (koji god oni bili). U trenutku vanjske smetnje, želimo li satelitu održati jednaku orijentaciju, zamašnjakom upravljamo na način da ćemo generirati jednaki moment po iznosu ali u suprotnom smjeru. Zamašnjak će se zarotirati u istu stranu kao i vanjski moment smetnje. Jednom kada smo pomoću zamašnjaka uveli jednaku kutnu količinu gibanja kao što ju je uvela vanjska smetnja, zamašnjaku moramo konstantno održavati kutnu brzinu. Bilo kakva daljnja promjena kutne brzine zamašnjaka uzrokuje promjenu kutne količine gibanja i samim time promjenu orijentacije satelita. Ako se s vremenom smetnje akumuliraju doći će do pojave tzv. saturacije zamašnjaka gdje će se zamašnjak nastojati okretati sve većom i većom brzinom sve dok ne dosegne maksimalnu moguću brzinu - saturacija. Drugi suptilni problem je taj što rotirajućem zamašnjaku konstantno moramo održavati kutnu brzinu što unosi negativnu energetsku računicu. Desaturacija je postupak s kojim se želi smanjiti kutna brzina zamašnjaka. Postupak desaturacije uključuje istovremeno usporavanje kutne brzine zamašnjaka i kompenzaciju novonastalog momenta pomoću nekih drugih aktuatora (npr. magnetorkera). Treći problem zamašnjaka leži u činjenici da su zamašnjaci mehanički uređaji s rotirajućim dijelovima te se očekuje da će s vremenom oni prestati raditi. Iz tog razloga umjesto 3 zamašnjaka za mogućnost troosnog upravljanja uzimamo 4. karakteristično položena zamašnjaka (vidi sliku \ref{fig:cetiri_zamasnjaka}) gdje je jedan zamašnjak redundantan. Pomoću takvog položaja moguće je imati troosno upravljanje orijentacijom s gdje jedan od zamašnjaka ne radi \cite{cetiriZamasnjaka}.

                \begin{figure}[htb]
                \centering
                \includegraphics[width=0.5\textwidth]{images/cetiri_zamasnjaka.jpg}
                \caption{Skup od 4 zamašnjaka tvrtke NanoAvionics gdje je jedan zamašnjak redundantan \cite{cetiriZamasnjakaTvrtka}.}
                \label{fig:cetiri_zamasnjaka}
                \end{figure}
            }
        }
    }

    \section{Algoritmi za određivanje i upravljanje orijentacijom}{
        U ovom dijelu navest ćemo algoritme i metode za određivanje i upravljanje orijentacijom satelita. 
 
        \subsection{Određivanje orijentacije}{
        \label{subsection:odredjivanje_orijentacije}
            Određivanje orijentacije je postupak u kojem iz odabranih orijentacijskih senzora (vidi poglavlje \ref{subsection:senzori_orijentacije}) prikupljamo podatke koje zatim obrađujemo unutar posebno razvijenih algoritama čiji rezultat računanja daje podatak o orijentaciji satelita. 

            Orijentacija satelita nije jednoznačno određena već u njoj postoje neodređenosti (greške). Takve neodređenosti najviše proizlaze iz neodređenosti orijentacijskih senzora. Druge, manje utjecajnije neodređenosti proizlaze iz konačne preciznosti aritmetičkih operacija računala na kojima se računaju takvi algoritmi. Zbog toga vrlo često govorimo o estimaciji orijentacije jer je podatak o orijentaciji više ili manje gruba procjena. Kako bi smanjili neodređenosti procjene orijentacije, najčešće uzimamo podatke iz više neovisnih senzora zajedno - \emph{Sensor fusion}. \emph{Sensor fusion} će smanjiti neodređenosti pojedinih senzora i u konačnici ćemo dobiti bolji rezultat procjene nego što bismo dobili korištenjem samo jednog senzora. Algoritmi za estimaciju orijentacije vrlo su često razvijeni tako da optimalno procjenjuju orijentaciju s obzirom na unaprijed definiran uvjet. 

            Najpoznatiji problem estimacije orijentacije satelita nazivamo engl. \emph{Wahba's Problem} iz 1965. godine \cite{wahbas_problem}. Nekoliko algoritama je razvijeno za potrebe rješavanja \emph{Wahba's} problema i neke od njih navest ćemo u nastavku poglavlja.

            U svrhu estimacije orijentacije važno je shvatiti nekoliko stvari. Algoritmi koje ćemo spomenuti, za svoj rad koriste podatke iz 2 različita troosna senzora položena u referentni sustav tijela (satelita). Za svaki od ta dva senzora moraju unaprijed biti poznate njihove tzv. referentne vrijednosti - vrijednosti vektora unutar inercijskog referentnog sustava. Iz razlika izmjerenih vrijednosti i njihovih referentnih vrijednosti moguće je dobiti podatak o orijentaciji. Za lakše shvaćanje pojma referentnog vektora navest ćemo primjer akcelerometra - uređaja koji, u ovom slučaju, mjeri akceleraciju Zemljine sile teže. Kao dogovor uzet ćemo primjer gdje je referentni vektor akcelerometra položen u referentni sustav kojemu Z komponenta gleda prema središtu Zemlje (X i Y komponenta za ovaj primjer nisu važne). U tom slučaju vrijedi da je vrijednost referentnog vektora jednaka $\left[0 \; 0 \; -9.81\right] m/s^2$. Dalje, uzmimo da je u jednom trenutku orijentacija senzora takva da gleda u suprotnom smjeru od središta Zemlje. U tom ćemo slučaju s akcelerometra pročitati vrijednost mjerenja iznosa $\left[0 \; 0 \; +9.81\right] m/s^2$. Iz usporedbe vrijednosti referentnog vektora i vektora mjerenja možemo lako zaključiti kako je orijentacija akcelerometra suprotna od orijentacije referentnog vektora i na taj način pretpostaviti orijentaciju.

            Algoritme za estimaciju orijentacije dijelimo u dvije skupine: bezmemorijske i memorijske \cite{uvod_u_svemirske}. Bezmemorijski algoritmi ne uzimaju u obzir prošlo stanje orijentacije, već podatak o orijentaciji dobivaju isključivo iz trenutno izmjerenih vrijednosti. S druge strane, memorijski algoritmi će na temelju prošlog stanja orijentacije i trenutno izmjerenih vrijednosti estimirati orijentaciju. Takav način estimacije je superiorniji jer je stanje u neposrednoj prošlosti ili isto, ili vrlo slično trenutnom stanju. 

            Jedan popularni bezmemorijski algoritam naziva se QUEST algoritam. Neki od memorijskih algoritama naziva su: REQUEST, Optimal-REQUEST, Komplementarni filtar i dr. O njima nešto više u nastavku. 

            \subsubsection{Wahba problem}{
                Kako bismo naveli i objasnili estimacijske algoritme, prvo je potrebno da definiramo Wahba problem. 

                Ako su nam dani dva skupa vektora sa $n\ge2$ elemenata $\left\{ \boldsymbol{r}_1, \boldsymbol{r}_2, \cdots , \boldsymbol{r}_n \right\}$ i $\left\{ \boldsymbol{b}_1, \boldsymbol{b}_2, \cdots , \boldsymbol{b}_n \right\}$, Wahba problem je problem pronalaženja orijentacijske matrice $A$ koja transformira prvi set vektora u drugi na način koji najbolje minimizira srednju kvadratnu pogrešku definiranu kao:

                \begin{equation}
                    \sum_{i=1}^{n}||\boldsymbol{b}_i - A\boldsymbol{r}_i||^2,
                \end{equation}

                gdje za matricu $A$ vrijedi $A^T A = \boldsymbol{I}_3$ i $\det(A)=1.$
            }

            \subsubsection{REQUEST algoritam}{
                REQUEST algoritam je jedan od algoritama koji rješava Wahba problem pronalaska orijentacijske matrice $A$. REQUEST algoritam je preteča QUEST algoritma koji je uzimao u obzir samo $n$ trenutno izmjerenih vektora i na temelju njih računao orijentacijsku matricu \cite{quest_algo}. REQUEST algoritam ide korak dalje i uvodi rekurziju. 

                Na temelju već dobivene orijentacijske matrice u prijašnjem $k$-tom koraku i novo izmjerenih $\boldsymbol{b}_i$ i $\boldsymbol{r}_i$ vektora senzora orijentacije, REQUEST algoritam će izračunati orijentacijsku matricu u $k+1$ koraku \cite{request_algo}.

                Osim izmjerenih $\boldsymbol{b}_i$ i $\boldsymbol{r}_i$ vektora, REQUEST algoritam uzima u obzir i trenutnu kutnu brzinu tijela pomoću koje točnije estimira orijentacijsku matricu. 

                Jedan problem REQUEST algoritma je što za estimaciju orijentacije zahtijeva par dodatnih fiksnih koeficijenata koji moraju biti eksperimentalno izabrani. Ti koeficijenti su zapravo težinski faktori koji govore kojim mjerenjima pridodajemo više važnosti: senzorima orijentacije ili mjerenju žiroskopa. Zbog tih fiksnih parametara REQUEST algoritam je suboptimalan \cite{opt_req_algo}. Problem suboptimalnosti rješava Optimal-REQUEST algoritam kojeg ćemo navesti u nastavku.

                Valja još spomenuti kako REQUEST algoritam nije općeniti algoritam koji će na izlazu dati estimaciju spomenute matrice $A$, već je to algoritam koji je specifično razvijen da na svom izlazu daje podatak o orijentaciji u obliku kvaterniona.
            }

            \subsubsection{Optimal-REQUEST algoritam}{
                Optimal-REQUEST algoritam je preteča REQUEST algoritma. Kao što smo već napomenuli ranije, REQUEST algoritam sadrži empirički izabrane koeficijente zbog kojih je takav algoritam suboptimalan. Optimal-REQUEST ide korak dalje: algoritam će s obzirom na propagaciju greške na senzorima orijentacije i žiroskopu sam mijenjati spomenute koeficijente na optimalan način. Metoda promijene koeficijenata zasniva se na tzv. Kalmanovom filtru \cite{opt_req_algo}.

                Nećemo ulaziti u detalje implementacije već ćemo samo navesti kako smo u sklopu ovog projekta razvili Optimal-REQUEST algoritam u MATLAB kodu, te smo ga pretvorili u C kod pomoću MATLAB Coder alata \cite{matlab_coder}. Cijeli programski kod dostupan je ovdje \cite{opt_req_kod} uz popratnu dokumentaciju ovdje \cite{opt_req_dokumen}. 
            }

            \subsubsection{Gradijentni spust \engl{Gradient descent}}{
                Ako posjedujemo dva para vektora mjerenja $(\boldsymbol{v}_1^i, \; \boldsymbol{v}_1^b)$ i $(\boldsymbol{v}_2^i, \; \boldsymbol{v}_2^b)$ gdje $\boldsymbol{v}_i^b$ označava vektor definiran u referentnom sustavu tijela $\mathcal{F}_b$, a $\boldsymbol{v}_i^i$ označava vektor definiran u inercijskom referentnom sustavu $\mathcal{F}_i$, moguće je definirati tzv. rotacijsku matricu $\mathcal{R}_i^b$ (vidi jednadžbu \ref{eq:rot_mat_quat}) koja transformira vektor $\boldsymbol{v}^i $ u vektor $\boldsymbol{v}^b$. 

                Cilj estimacijskog algoritma je izračunati orijentacijsku matricu tako da smanjimo pogrešku estimacije. Pogrešku estimacije $\boldsymbol{e_i} = \left[e_{x,i} \; e_{y,i} \; e_{z,i}\right]^T$ za svaki par mjerenih vektora definiramo kao:

                \begin{equation}
                \begin{array}{rcl}
                    \boldsymbol{e}_1 & = & \mathcal{R}_i^b \boldsymbol{v}_1^i - \boldsymbol{v}_1^b, \\
                    \boldsymbol{e}_2 & = & \mathcal{R}_i^b \boldsymbol{v}_2^i - \boldsymbol{v}_2^b. 
                \end{array}
                \end{equation} 

                Nadalje, definirat ćemo tzv. funkciju cilja. Funkcija cilja u gradijentnom spustu je parametar kojeg želimo maksimalno smanjiti. Funkciju cilja definiramo kao:

                \begin{equation}
                    J(\boldsymbol{q}_i^b) = \boldsymbol{e}_1^T \boldsymbol{e}_1 + \boldsymbol{e}_2^T \boldsymbol{e}_2
                \end{equation}

                Konačno, algoritam gradijentnog spusta definiramo kao:

                \begin{equation}
                \label{eq:grad_des}
                    \boldsymbol{q}_{n+1} = \boldsymbol{q}_n - \alpha\nabla J(\boldsymbol{q}_n),
                \end{equation}

                gdje je gradijent funkcije cilja $\nabla J(\boldsymbol{q}_n)$ definiramo kao:

                \begin{equation}
                    \nabla J(\boldsymbol{q}_n) = 
                    \begin{bmatrix}
                        2 \boldsymbol{e}_1^T \boldsymbol{M}_1 \boldsymbol{v}_1^i(\boldsymbol{q}_n) + 2 \boldsymbol{e}_2^T \boldsymbol{M}_1 \boldsymbol{v}_2^i(\boldsymbol{q}_n) \\
                        2 \boldsymbol{e}_1^T \boldsymbol{M}_2 \boldsymbol{v}_1^i(\boldsymbol{q}_n) + 2 \boldsymbol{e}_2^T \boldsymbol{M}_2 \boldsymbol{v}_2^i(\boldsymbol{q}_n) \\
                        2 \boldsymbol{e}_1^T \boldsymbol{M}_3 \boldsymbol{v}_1^i(\boldsymbol{q}_n) + 2 \boldsymbol{e}_2^T \boldsymbol{M}_3 \boldsymbol{v}_2^i(\boldsymbol{q}_n) \\
                        2 \boldsymbol{e}_1^T \boldsymbol{M}_4 \boldsymbol{v}_1^i(\boldsymbol{q}_n) + 2 \boldsymbol{e}_2^T \boldsymbol{M}_4 \boldsymbol{v}_2^i(\boldsymbol{q}_n)
                    \end{bmatrix}
                    ,
                \end{equation}

                i gdje su sve parcijalne derivacije rotacijske matrice $\mathcal{R}_i^b$ definirane kao:

                \begin{equation}
                \begin{array}{rcl}
                    \boldsymbol{M}_1 = \frac{\partial \mathcal{R}_i^b}{\partial q_1} = 2
                    \begin{bmatrix}
                        q_1 & q_4 & -q_3 \\
                        -q_4 & q_1 & q_2 \\
                        q_3 & -q_2 & q_1 
                    \end{bmatrix},
                    & 
                    \boldsymbol{M}_2 = \frac{\partial \mathcal{R}_i^b}{\partial q_2} = 2
                    \begin{bmatrix}
                        q_2 & q_3 & q_4 \\
                        q_3 & -q_2 & q_1 \\
                        q_4 & -q_1 & -q_2 
                    \end{bmatrix},
                    \\
                    & & \\
                    \boldsymbol{M}_3 = \frac{\partial \mathcal{R}_i^b}{\partial q_3} = 2
                    \begin{bmatrix}
                        -q_3 & q_2 & -q_1 \\
                        q_2 & q_3 & q_4\\
                        q_1 & q_4 & -q_3 
                    \end{bmatrix},
                    & 
                    \boldsymbol{M}_4 = \frac{\partial \mathcal{R}_i^b}{\partial q_4} = 2
                    \begin{bmatrix}
                        -q_4 & q_1 & q_2 \\
                        -q_1 & -q_4 & q_3 \\
                        q_2 & q_3 & q_4 
                    \end{bmatrix}.
                \end{array}
                \end{equation}

                Procjena orijentacijskog kvaterniona započinje odabirom inicijalnog kvaterniona $\boldsymbol{q}_0$. Za inicijalni kvaternion najčešće se uzima proizvoljna vrijednost (ako drugačije nije moguće) npr. $\boldsymbol{q}_0 = \left[1, \; 0, \; 0, \; 0\right]^T$. Svaki sljedeći korak uključuje potraživanje mjerenih vektora iz orijentacijskih senzora i računanje procjene orijentacije jednadžbom \ref{eq:grad_des}.

                Problem opisane procijene orijentacijskog kvaterniona metodom gradijentnog spusta je što takva procjena sadrži visokofrekventne komponente šuma. Takav šum moguće je filtrirati niskopropusnim filtrom, međutim, postoji bolji način filtriranja. Naime, kao što je bilo rečeno u poglavlju \ref{subsection:senzori_kutne_brzine}, orijentaciju je moguće izračunati iz mjerenog vektora kutne brzine (vidi jednadžbu \ref{eq:rot_qib_elem}) relacijom \cite{uvod_u_svemirske}:

                \begin{equation}
                    \boldsymbol{q}_k = \boldsymbol{q}_{k-1} + \Delta T \dot{\boldsymbol{q}}_k = \boldsymbol{q}_{k-1} + \frac{\Delta T}{2} \boldsymbol{S}(\boldsymbol{\omega}_{bG}) \boldsymbol{q}_{k-1},
                \end{equation}

                gdje je $\Delta T$ proteklo vrijeme od prošlog računanja.

                Problem takvog načina određivanja orijentacije je akumulirana greška. Takvu akumuliranu grešku moguće je filtrirati visokopropusnim filtrom. 

                Želimo li riješiti problem visokofrekventne komponente šuma orijentacijskog kvaterniona i akumulirane greške kutne brzine pokušat ćemo spojiti obje metode procijene orijentacije u jednu metodu. Tako ćemo u konačnici dobiti procjenu koja rezultira manjom greškom. U tu svrhu uvest ćemo tzv. komplementarni filtar \cite{uvod_u_svemirske}.
            }

            \subsubsection{Komplementarni filtar}{
                Komplementarni filtar zasniva se na ideji gdje izlaz filtra ovisi o dvije ulazne vrijednosti i to na način da filtru sa težinskim faktorom $K \in \left[ 0, \; 1\right]$ odredimo hoće li izlaz ovisiti o prvom, odnosno o drugom ulaznom parametru. 

                Cijela logika računanja orijentacijskog kvaterniona može se opisati dijagramom na slici \ref{fig:komp_filt_fig}. Obratimo pažnju na to kako s obzirom na težinski faktor $K$, izlaz filtra ovisi o jednom ili o drugom ulaznom parametru. Ako vrijedi da je $K = 1$, izlaz komplementarnog filtra (procijenjena orijentacija) ovisi isključivo o algoritmu određivanja orijentacije pomoću vektora kutne brzine. Obrnuto, ako je $K = 0$, izlaz filtra isključivo ovisi o algoritmu procijene orijentacije pomoću gradijentnog spusta \cite{grad_desc}. Parametar $K$ određuje se eksperimentalnim putem ili simulacijom. 

                \begin{figure}[htb]
                \centering
                \includegraphics[width=1.0\textwidth]{images/komp_filt_fig.png}
                \caption{Prikaz komplementarnog filtra za određivanje orijentacije satelita pomoću gradijentnog spusta i vektora kutne brzine \cite{uvod_u_svemirske}.}
                \label{fig:komp_filt_fig}
                \end{figure}
            }
        }

        % TODO DODAJ VRIJEDNOSTI KOMPL FILTRA I PID REGULATORA

        \subsection{Upravljanje orijentacijom/kutnom brzinom}{
            \subsubsection{Korišteni aktuatori}{
                U našem radu za kontrolu orijentacije upotrijebili smo zamašnjak. Zamašnjak je pogonjen elektromotorom. Elektromotor se upravlja pomoću upravljivog H-mosta koji omogućuje promjenu smjera. Brzinom elektromotora upravlja se pomoću pulsno širinske modulacije \engl{Pulse Width Modulation - PWM}. Rotirajuća masa izrađena je na 3D printeru.

                Razlog zašto smo odabrali zamašnjak za upravljanje orijentacijom je u tome što je to bio najjednostavniji aktuator za izvedbu. Magnetorker bi zahtijevao izradu posebnog kaveza koji zamjenjuje Zemljino magnetsko polje što dodatno komplicira testni sustav.

                PWM modulacija generira se u sklopovlju mikroupravljača.
            }

            \subsubsection{Korišteni algoritmi}{
                U našem sustavu implementirane su dvije regulacijske petlje: prva koja upravlja kutnom brzinom satelita i druga koja upravlja orijentacijom. Radi jednostavnosti obje regulacijske petlje reguliraju orijentaciju/kutnu brzinu samo oko jedne osi.

                Upravljanje orijentacijom satelita prvo započinje određivanjem orijentacije. Jednom kada je orijentacija određena, upravljački PWM signal upravlja elektromotorom. Isto vrijedi i za upravljanje kutnom brzinom satelita. 

                Za obje regulacijske petlje koristimo PID regulator oblika:

                \begin{equation}
                    u(t) = K_p e(t) + K_i \int_{}^{}{e(t)dt} + K_d \frac{de(t)}{dt},
                \end{equation}

                gdje je $u(t)$ upravljački izlaz regulatora, $e(t)$ razlika željene i trenutne veličine koje reguliramo, $K_p$, $K_i$ i $K_d$ koeficijenti PID regulatora.

                Za implementaciju PID regulatora u računalu pogodan je diskretizirani oblik. Diskretizirani oblik PID regulatora \cite{diskr_pid} definiramo kao:

                \begin{equation}
                    u(k) = K_P e(k) + K_I \sum_{}^{}{e(k)} + K_D (e(k) - e(k-1)),
                \end{equation}

                gdje su koeficijenti diskretiziranog regulatora jednaki:

                \begin{equation}
                    \begin{array}{rcl}
                        K_P & = & K_p,\\
                        K_I & = & \frac{K_p T}{T_i}, \\
                        K_D & = & \frac{K_p T_d}{T},
                    \end{array}
                \end{equation}

                i gdje je parametar $T$ jednak vremenskom periodu pozivanja regulacijske petlje.

                Razliku trenutne i željene vrijednosti $e(k)$ dovodimo na ulaz diskretiziranog PID regulatora koji zatim na izlazu daje upravljački signal $u(k)$. Upravljački signal PID regulatora je u intervalu $u(k) \in \left[ 0, 100 \right]$ što nam direktno daje tzv. \emph{Duty cycle} (DC) PWM-a. DC računamo kao \cite{dc_pwm}:

                \begin{equation}
                    DC = \frac{T_{on}}{T_{on} + T_{off}} \times 100 \left[ \% \right],
                \end{equation}

                gdje je parametar $T_{on}$ jednak vremenu visokog stanja PWM signala, a parametar $T_{off}$ jednak vremenu niskog stanja PWM signala (odnosno 0). Zbroj vremena visokog i niskog stanja PWM-a daje nam period PWM signala $T_{\text{PWM}} = T_{on} + T_{off}$. Ako vrijedi da je $T_{on}=T_{\text{PWM}}$ to znači da je srednja vrijednost PWM signala jednaka naponu napajanja PWM-a. Vrijedi i obrnuto, ako je $T_{off}=T_{\text{PWM}}$ onda srednja vrijednost PWM signala iznosi 0.

                Odabir PID koeficijenata za obje regulacijske petlje opisan je u poglavlju \ref{subsection:pid_regulator}.
            }
        }
    }

    \section{Razvijeni sustav}{
        U ovom poglavlju bit će opisana razvijena tiskana pločica i sklopovlje. Također, navest ćemo izabrane orijentacijske senzore i aktuatore.

        Cijeli ADCS sustav nalazi se unutar polusferične kugle koja je položena na zračni ležaj prikazan na slici \ref{fig:slika_sustava}.

        \begin{figure}[htb]
        \centering
        \includegraphics[width=0.5\textwidth]{images/slika_sustava.png}
        \caption{Prikaz ADCS sustava sa pripadajućim zračnim ležajem.}
        \label{fig:slika_sustava}
        \end{figure}

        \subsection{Tiskana pločica i sklopovlje}{
            Tiskana pločica sa sklopovljem prikazana na slici \ref{fig:plocica_3d} i sastoji se od nekoliko dijelova:

            \begin{itemize}
            \item Baterija,
            \item Napajanje,
            \item Pogonska elektronika zamašnjaka,
            \item Elektromotor,
            \item Bluetooth modul,
            \item Inkrementalni enkoder,
            \item IMU modul,
            \item Nucleo pločica.
            \end{itemize}

            \begin{figure}[htb]
            \centering
            \includegraphics[width=1.0\textwidth]{images/plocica_3d.png}
            \caption{3D prikaz tiskane pločice ADCS sustava.}
            \label{fig:plocica_3d}
            \end{figure}

            Shema tiskane pločice nalazi se na slici \ref{fig:plocica_shema}. Napon sa baterija dolazi do napajačkog sklopovlja (oznaka \texttt{Buck converter module}) koji smanjuje napon do razine pogodne za napajanje sklopovlja. Pogonska elektronika zamašnjaka (\texttt{Motor driver module}) oznake Pololu DRV8838 \cite{pololu} je mali H-most modul za upravljanje elektromotorom zamašnjaka. Elektromotor je male snage i nalazi se u sredini tiskane pločice (\texttt{Motor}). Na tiskanoj pločici se također nalazi i Bluetooth modul oznake \emph{HM-06} (\texttt{Bluetooth module}). Bluetooth modul nalazi se na samom rubu tiskane pločice radi bolje transmisije signala. Osim Bluetooth modula tu je i inkrementalni enkoder (\texttt{Incremental encoder}) pomoću kojeg je moguće izmjeriti kutnu brzinu zamašnjaka. Funkcionalnost inkrementalnog enkodera u trenutku pisanja rada još nije implementirana. Nadalje, na pločici se nalazi i IMU modul (\texttt{IMU unit module}) oznake \emph{MPU9250} koji na sebi sadrži IMU \engl{Inertial Measurement Unit} senzor. Na kraju, pločica sadrži i utor za Nucleo pločicu (\texttt{NUCLEO-L412KB}) \cite{nucleo_um} koju je moguće jednostavno izvaditi i natrag staviti. Radi lakšeg razvijanja programske podrške na pločici se nalazi nekoliko statusnih LED dioda.

            Na Nucleo pločici morali smo napraviti nekoliko preinaka. Naime, naišli smo na problem postavljanja točne brzine prijenosa UART-a \engl{baudrate} na \texttt{UART1} periferiji (vidi \cite{uc_um}). \texttt{UART1} periferiji smo postavili standardnu brzinu prijenosa od 115200 bits/s da bi na izlazu dobili brzinu prijenosa od oko 108000 bits/s. Razlog tomu je što je Nucleo pločica tvornički postavljena da koristi oscilator unutar mikroupravljača koji je vrlo neprecizan. Da bi konfigurirali pločicu da koristi vanjski oscilator, morali smo fizički odlemiti kratkospojnike \texttt{SB5} i \texttt{SB7} i kratko spojiti kratkospojnik \texttt{SB17} (vidi \cite{nucleo_um}). Svatko tko želi koristiti programsku podršku opisanu u ovom radu mora napraviti jednake promjene na Nucleo pločici.

            \begin{figure}[htb]
            \centering
            \includegraphics[width=1.0\textwidth]{images/plocica_shema.png}
            \caption{Shema tiskane pločice ADCS sustava.}
            \label{fig:plocica_shema}
            \end{figure}
        }

        \subsection{Izabrani senzori}{
            Zbog prirode algoritama za procjenu orijentacije (vidi poglavlje \ref{subsection:odredjivanje_orijentacije}), potrebno je imati 2 neovisna troosna senzora. U praksi bi to npr. mogli biti senzor Sunca i magnetometar. U našem slučaju, radi jednostavnosti izvedbe testnog sustava i samog testiranja algoritma za estimaciju, izabrali smo akcelerometar kao prvi, odnosno magnetometar kao drugi senzor. 

            Oba troosna senzora (plus troosni žiroskop) nalaze se u jedinstvenom kućištu IMU senzora oznake \emph{MPU9250} \cite{mpu9250_datasheet}. U našem sustavu koristimo Arduino modul sa MPU9250 senzorom prikazanom na slici \ref{fig:mpu9250}.

            \begin{figure}[htb]
            \centering
            \includegraphics[width=0.25\textwidth]{images/mpu9250.jpg}
            \caption{Arduino modul sa MPU9250 senzorom \cite{wolles_mpu9250}.}
            \label{fig:mpu9250}
            \end{figure}

            \subsubsection{Akcelerometar}{
                Akcelerometar mjeri trenutnu akceleraciju na tijelo/senzor. Korištenje akcelerometra kao senzora orijentacije donosi dva problema: prvi problem je taj što se akcelerometar ne može koristiti u sustavima koji ne akceleriraju (npr. sateliti u orbiti oko Zemlje) jer u takvim sustavima ne postoji akceleracija. Drugi problem je što je akcelerometar senzor koji posjeduje relativno puno visokofrekventnog šuma, ali zato ne posjeduje tzv. \emph{bias}. 
            }

            \subsubsection{Magnetometar}{
                Magnetometar nam za podatak daje vektor Zemljinog magnetskog polja. Pomoću dostupnih alata na internetu (vidi \cite{magnetic_model}), moguće je odrediti referentni vektor Zemljinog magnetskog polja za odabrano mjesto na Zemlji. Magnetometar je povoljan orijentacijski senzor zato što ga je moguće koristiti u Zemljinoj orbiti. Ako bi znali podatak o referentnom vektoru magnetskog polja Zemlje za svaku točku orbite i imali izmjerenu vrijednost Zemljinog magnetskog polja, mogli bismo pomoću estimacijskog algoritma izračunati orijentaciju satelita u orbiti.
            }

            \subsubsection{Žiroskop}{
                Kao što smo ranije spomenuli, za uspješniju estimaciju orijentacije koristimo žiroskop. Unutar IMU senzora nalazi se troosni žiroskop.
            }
        }

        \subsection{Izabrani aktuatori}{
            Za kontrolu orijentacije izradili smo zamašnjak kojeg je moguće vidjeti na slici \ref{fig:zamasnjak}. Elektromotor zamašnjaka položen je na tiskanu pločicu ADCS sustava. Rotirajuću masu zamašnjaka izradili smo pomoću 3D printera. 

            Zamašnjak smo izabrali zato što je to aktuator kojeg je relativno lako izraditi, dijelovi su lako dostupni, za pogon je potrebna samo električna energija koja dolazi iz baterije i pogonska elektronika elektromotora je jednostavne izvedbe.
 
            \begin{figure}[htb]
            \centering
            \includegraphics[width=0.7\textwidth]{images/zamasnjak.png}
            \caption{Prikaz zamašnjaka sa ADCS sustavom.}
            \label{fig:zamasnjak}
            \end{figure}
        }
    }
}

\chapter{Programska podrška ADCS sustava}{
    U ovom poglavlju opisati ćemo programsku podršku ADCS sustava i opisat ćemo ugradbeno računalo koje koristimo za računanje i kontrolu aktuatora. Objasnit ćemo organizaciju programske podrške, navest ćemo korištene biblioteke, operacijski sustav, opisati funkcionalnost programa i u konačnici, ukratko opisati postupak razvijanja programske podrške. Napominjemo kako sljedeći opis sustava vrijedi isključivo za stanje sustava u trenutku pisanja ovog rada i moguće je da u trenutku čitanja postoje određene razlike. 

    Cijela programska podrška nalazi se na GitHub repozitoriju autora ovdje \cite{github_repo}. Programska podrška verzionirana je pomoću Git \cite{git} programa za verzioniranje. Objašnjenja i opisi programske podrške vrijede do \texttt{f4d98b3} \emph{commit}-a \cite{git_commit}.

    \section{Ugradbeno računalo}{
        Ugradbeno računalo koje koristimo je već gotov sustav na \emph{NUCLEO-L412KB} razvojnoj pločici \cite{nucleo_um} STM proizvođača. Takav gotov sustav omogućuje nam jednostavno i brzo razvijanje programske podrške. 

        Nucleo razvojna pločica se sastoji od \emph{STM32L412KBU6U} mikroupravljača niske potrošnje \cite{uc_um} koji sadrži tzv. jedinicu za računanje aritmetike pomičnog zareza \engl{Floating point unit - FPU}. FPU nam omogućava hardversko ubrzanje računanja algoritama. Osim mikroupravljača, pločica sadrži i tzv. \emph{ST-LINK} sučelje za jednostavno \emph{debugiranje} i pohranu programa. Na samoj pločici nalazi se i upravljiva LED dioda.
    }

    \section{Organizacija projekta}{
        Programski kod podijeljen je u nekoliko direktorija i poddirektorija. Pogled iz glavnog direktorija sa opisom svakog poddirektorija prikazan je u tablici \ref{tbl:pogled_iz_glavnog_direktorija}.

        Nepotrebno je ulaziti u detalje svakog direktorija već ćemo u nastavku opisati samo što se nalazi unutar \texttt{src} direktorija koji sadrži programsku podršku ADCS sustava. Pogled iz \texttt{src} direktorija i opis svakog direktorija moguće je vidjeti je u tablici \ref{tbl:pogled_iz_src_direktorija}.

        \begin{table}[htb]
        \caption{Pogled iz glavnog direktorija projekta.}
        \label{tbl:pogled_iz_glavnog_direktorija}
        \centering
        \begin{tabular}{lll} 
        \toprule
        Naziv & Tip & Opis \\ 
        \midrule
        cmake           & Direktorij & Pomoćne CMake datoteke \\
        docs            & Direktorij & Popratnu dokumentaciju \\
        .git            & Direktorij & Git verzioniranje \\
        .github         & Direktorij & GitHub CI server \\
        scripts         & Direktorij & Pomoćne Shell skripte \\
        src             & Direktorij & Programska podrška \\
        tests           & Direktorij & Testovi programske podrške \\
        .vscode         & Direktorij & Pomoćne datoteke za VSCode editor \\
        .clang-format   & Datoteka   & Konfiguracija za clang-format \\
        CMakeLists.txt  & Datoteka   & CMake konfiguracija projekta \\
        .gitignore      & Datoteka   & Imena direktorija/datoteka koje Git ne verzionira \\
        .gitmodules     & Datoteka   & Imena i poveznice (linkovi) na eksterne Git repozitorije \\
        LICENSE         & Datoteka   & Licenca projekta \\
        Makefile        & Datoteka   & GNU Make komande za olakšano prevođenje (kompajliranje) \\
        README.md       & Datoteka   & Opis projekta \\
        \bottomrule
        \end{tabular}
        \end{table}

        \begin{table}[htb]
        \caption{Pogled iz \texttt{src} direktorija.}
        \label{tbl:pogled_iz_src_direktorija}
        \centering
        \begin{tabular}{lll} 
        \toprule
        Naziv & Tip & Opis \\ 
        \midrule
        bsp         & Direktorij & engl. \emph{Board support package} \\
        core        & Direktorij & Postavljanje osnovnih periferija mikroupravljača (clock, memorija itd.) \\
        drivers     & Direktorij & Drajveri za periferiju (I2C, UART, PWM, tajmeri itd.) \\
        libs        & Direktorij & Eksterne biblioteke (Bluetooth, MPU9250, komplementarni filtar itd.) \\
        linker      & Direktorij & Linker datoteke \\
        mcu         & Direktorij & Drajveri za periferiju (ali za naš mikroupravljač) \\
        middlewares & Direktorij & Programski kod dretvi/aplikacije \\
        rtos        & Direktorij & Datoteke RTOS-a \\
        utils       & Direktorij & tzv. \emph{Error handling}, matematičke funkcije \\
        main.c      & Direktorij & Main (glavna) funkcija \\
        main.h      & Direktorij & Main (glavna) funkcija \\
        \bottomrule
        \end{tabular}
        \end{table}
    }
    
    \section{Korištene biblioteke}{
        U sklopu programske podrške koristimo i nekoliko biblioteka:

        \begin{itemize}
        \item comp\_filt,
        \item mpu9250,
        \item optimal\_request,
        \item printf,
        \item zs040.
        \end{itemize}

        Neke biblioteke su samostalni GitHub repozitoriji i u projekt su dodani kao tzv. Git submoduli. Primjer takvih biblioteka su: \texttt{mpu9250} koja upravlja MPU9250 IMU senzorom, \texttt{optimal\_request} biblioteka koja sadrži kod za Optimal-REQUEST algoritam, \texttt{printf} biblioteka koja sadrži jednostavniju verziju klasične \texttt{printf} funkcije i \texttt{zs040} biblioteka koja upravlja Bluetooth modulom. \texttt{comp\_filt} biblioteka je jedina biblioteka koja nije u zasebnom GitHub repozitoriju i sadrži programski kod za Komplementarni filtar. 

        Svrha eksternih GitHub repozitorija (submodula) je u tome što to mogu biti samostalni repozitoriji koje netko drugi može preuzeti i ukomponirati u svoj projekt neovisno o tome na kojem sustavu se oni pokreću. Netko tko želi iskoristiti npr. Optimal-REQUEST biblioteku u svojem projektu može ju jednostavno dodati u svoj repozitorij kao Git submodul. 
    }

    \section{Operacijski sustav i funkcionalnost}{
        Zahtjev ADCS sustava je da u realnom vremenu obavlja nekoliko stvari istovremeno:

        \begin{enumerate}
        \item Estimacija orijentacije,
        \item Kontrola orijentacije,
        \item Komunikacija.
        \end{enumerate}

        Za mogućnost istovremenog (paralelizam) izvršavanja nekoliko stvari istovremeno, odlučili smo se za operacijski sustav (OS). Zbog toga što se ADCS sustav odvija u realnom vremenu izabrali smo operacijski sustav u stvarnom vremenu \engl{Real Time Operating System - RTOS}.

        \subsection{Operacijski sustav i dretve}{
            Zbog popularnosti i široke zajednice, odlučili smo se za \emph{FreeRTOS} operacijski sustav. \emph{FreeRTOS} je besplatni operacijski sustav otvorenog koda koji sadrži podršku za mikroupravljač kojeg koristimo \cite{freertos}. 
    
            Sustav smo podijelili u nekoliko dretvi koje se izvršavaju paralelno:
            \begin{enumerate}
            \item Dretva budnosti \engl{Alive thread},
            \item Dretva za estimaciju i kontrolu orijentacije,
            \item Dretva za komunikaciju.
            \end{enumerate}

            Shematski prikaz svih dretvi sa međusobnom komunikacijom moguće je vidjeti na slici \ref{fig:dijagram_dretvi}. Detaljan opis svake dretve slijedi u nastavku.

            \begin{figure}[htb]
            \centering
            \includegraphics[width=0.85\textwidth]{other/dijagram_dretvi.png}
            \caption{Prikaz svih dretvi s međusobnim komunikacijskim kanalima.}
            \label{fig:dijagram_dretvi}
            \end{figure}

            \subsubsection{Dretva budnosti}{
                Dretva budnosti je jednostavna dretva u kojoj se periodički pali i gasi LED statusna dioda na samoj Nucleo pločici. Dretva budnosti nam omogućuje vizualnu provjeru rada sustava. Ako iz nekog razloga izvršavanje sustava prestane, korisnik će na oko vidjeti kako statusna LED dioda ne treperi. To je znak kako je sustav otišao u neodređeno stanje. Pseudokod dretve budnosti nalazi se u nastavku:

                \begin{lstlisting}[language=C]
while(True) {
    promijeni_stanje_statusne_ledice();
    čekaj_100_milisekundi();
}               \end{lstlisting}
            }
    
            \subsubsection{Dretva za estimaciju i kontrolu orijentacije}{
                Dretva za estimaciju i kontrolu orijentacije (ADCS dretva) sadrži programski kod koji periodički estimira trenutnu orijentaciju i na temelju toga upravlja regulacijskim petljama. Pseudokod ADCS dretve nalazi se u nastavku:
        
                \begin{lstlisting}[language=C]
pričekaj_3_sekunde_za_stabilizaciju_satelita();

inicijaliziraj_imu();
inicijaliziraj_komplementarni_filtar();
inicijaliziraj_zamašnjak();
inicijaliziraj_regulacijske_petlje();

while(True) {
  imu_mjerenje = izmjeri_imu_vrijednosti();

  vrsta_regulacije = potraži_vrstu_regulacije();
  if (vrsta_regulacije == REGULACIJA_ORIJENTACIJE) {
    kvaternion = estimiraj_orijentaciju(imu_mjerenje);

    izmjereni_kut = izračunaj_eulerov_kut_z(kvaternion);
    željeni_kut = potraži_željeni_eulerov_kut();
    reguliraj_orijentaciju_oko_z_osi(željeni_kut, izmjereni_kut);

    izlaz_regulatora = potraži_izlaz_pid_regulatora_orijentacije();

    pošalji_preko_bluetootha(željeni_eulerov_kut, 
      izmjereni_eulerov_kut, 
      izlaz_regulatora);

  } else if (vrsta_regulacije == REGULACIJA_KUTNE_BRZINE) {
    željena_kutna_brzina = potraži_željenu_kutnu_brzinu();
    reguliraj_kutnu_brzinu_oko_z_osi(željena_kutna_brzina, 
      imu_mjerenje.žiroskop.z);

    izlaz_regulatora = potraži_izlaz_pid_regulatora_kutne_brzine();
    pošalji_preko_bluetootha(željena_kutna_brzina, 
      imu_mjerenje.žiroskop.z, 
      izlaz_regulatora);

  } else if (vrsta_regulacije == BEZ_REGULACIJE) {
      kvaternion = estimiraj_orijentaciju(imu_mjerenje);
      kutovi = izračunaj_eulerove_kutove(kvaternion);
      željeni_kut = potraži_željeni_eulerov_kut();
      zamašnjak = potraži_duty_cycle_zamašnjaka();

      pošalji_preko_bluetootha(kutovi, 
        imu_mjerenje.žiroskop, 
        zamašnjak);
  }

  čekaj_100_milisekundi();
}               \end{lstlisting}

                Pogledamo li pseudokod ADCS dretve vidjet ćemo da na samom početku imamo čekanje od 3 sekunde ne bi li se satelit smirio. Razlog tomu je što na samom početku inicijalizacije sustava imamo kalibraciju žiroskopa. Kalibracija žiroskopa nastoji pronaći konstantni bias pod uvjetom da je satelit u mirovanju, odnosno da je kutna brzina za svaku os jednaka 0. Tih 3 sekunde čekanja nam omogućuje da nakon ponovnog pokretanja sustava, imamo vremena satelit negdje položiti i pričekati da prođe vrijeme kalibracije.

                Nakon 3 sekunde čekanja slijedi inicijalizacija IMU jedinice, komplementarnog filtra, zamašnjaka i obje regulacijske petlje.

                Nakon inicijalizacije slijedi beskonačna petlja gdje se prvo potražuje mjerenje s IMU jedinice. IMU jedinica dat će podatke o vektorima akceleracije, magnetskog polja i kutne brzine za svaku os. 

                Jednom kada smo dobili vrijednosti mjerenja, slijedi potraživanje globalnog stanja regulacije. Postoje 3 globalna stanja regulacije: 

                \begin{enumerate}
                    \item Regulacija orijentacije oko z-osi,
                    \item Regulacija kutne brzine oko z-osi,
                    \item Bez regulacije.
                \end{enumerate}

                Sva 3 stanja zapravo dolaze iz komunikacijske dretve koja omogućuje da korisnik u bilo koje vrijeme odabere jedan od tih stanja (vidi komande koje pruža komunikacijska dretva). Inicijalno stanje regulacije nakon svakog ponovnog pokretanja sustava je stanje bez regulacije.

                Stanje regulacije orijentacije započinje estimacijom orijentacije. Funkcija koja estimira orijentaciju kao podatak prima mjerenja iz IMU jedinice (koristi sva 3 podatka), a na izlazu daje procijenjeni kvaternion. Funkcija za estimaciju orijentacije u pozadini poziva komplementarni filtar koji estimira kvaternion. Nakon što smo dobili kvaternion, računamo Eulerov kut oko z-osi. Nadalje, potražujemo željeni Eulerov kut koji zapravo dolazi također iz komunikacijske dretve jer korisnik u svakom trenutku može promijeniti željeni kut. Pomoću izračunatog (estimiranog) kuta i željenog kuta pozivamo funkciju za regulaciju orijentacije. U pozadini ta funkcija poziva PID regulacijsku petlju za kontrolu orijentacije (kuta). Na samom kraju dretve Bluetooth-om se šalju podaci korisniku o vrijednosti željenog (referentnog) Eulerovog kuta, trenutnog (estimiranog) Eulerovog kuta i izlazu PID regulatora. Te tri vrijednosti važne su nam u proučavanju odziva satelita prilikom regulacije orijentacije. 

                Stanje regulacije kutne brzine započinje pozivanjem funkcije regulacijske petlje za regulaciju kutne brzine. Funkcija koja regulira kutnu brzinu kao podatak prima mjerenja iz žiroskopa (samo z-os) i željenu kutnu brzinu. Željenu kutnu brzinu potražujemo iz komunikacijske dretve koja omogućava da korisnik u svakom trenutku promijeni željenu kutnu brzinu. Funkcija za regulaciju kutne brzine u pozadini poziva funkciju za PID regulaciju kutne brzine. Pri samom kraju dretve šaljemo korisniku podatke o vrijednosti željene (referentne) kutne brzine, trenutne (izmjerene) kutne brzine i izlaz PID regulatora. 

                Stanje bez regulacije započinje estimiranjem orijentacije, računanjem Eulerovih kutova i čitanjem vrijednosti Duty Cycle-a zamašnjaka (trenutne i referente). Sve to na kraju zajedno pošaljemo korisniku. Ti podaci su nam važni za snimanje odziva satelita na tzv. Step pobudu i računanje koeficijenata pojednostavljenog modela (vidi poglavlje \ref{subsection:kinematicki_model}).

                Na samom kraju dretve slijedi čekanje od 100 milisekundi. Obratimo pažnju i na to da obje regulacijske petlje ovise o periodu izvođenja ADCS dretve.
            }

            \subsubsection{Dretva za komunikaciju}{
                Dretva za komunikaciju sadrži programski kod koji je zaslužan za komunikaciju sa satelitom. Komunikacija sa satelitom odvija se u oba smjera: od korisnika prema sustavu i od sustava prema korisniku. Komunikacija se vrši preko Bluetooth-a. Bluetooth komunikacija nam omogućuje jednostavno pristupanje satelitu pomoću računala ili  pametnog telefona koji sadrži Bluetooth sučelje.

                Komunikacijska dretva omogućava slanje podataka o trenutnom stanju satelita kao što su: trenutna orijentacija, kutna brzina, izlaz regulatora i sl. Druga bitna funkcionalnost dretve je mogućnost upravljanja satelitom od strane korisnika pomoću komandnog sučelja. Popis svih podržanih komandi upravljanja satelitom prikazani su u tablici \ref{tbl:lista_komandi}.

                \begin{table}[htb]
                \caption{Popis komandi, njihov opis i primjer korištenja. \textbf{Obratite pažnju kako svaka komanda u primjeru mora završavati sa '\textbackslash n' ASCII znakom.}}
                \label{tbl:lista_komandi}
                \centering
                \begin{tabular}{lll} 
                \toprule
                Komanda & Opis & Primjer korištenja \\ 
                \midrule
                echo                     & Vraća nazad korisniku sve primljeno          & \texttt{echo(ADCS)}                           \\
                help                     & Ispisuje sve podržane komande                & \texttt{help()}                               \\
                reset                    & Ponovno pokretanje sustava                   & \texttt{reset()}                              \\
                set\_sending             & Omogućuje/onemogućuje slanje poruka          & \texttt{set\_sending(1)}, (ili \texttt{0})    \\
                set\_reg\_angvel         & Pokreće regulaciju kutne brzine              & \texttt{set\_reg\_angvel()}                   \\
                set\_reg\_attitude       & Pokreće regulaciju orijentacije              & \texttt{set\_reg\_attitude()}                 \\
                set\_reg\_no\_reg        & Onemogućuje regulaciju                       & \texttt{set\_reg\_no\_reg()}                  \\
                set\_pid\_p              & Postavlja P član aktivnog PID regulatora     & \texttt{set\_pid\_p(3.14)}                    \\
                set\_pid\_i              & Postavlja I član aktivnog PID regulatora     & \texttt{set\_pid\_i(15)}                      \\
                set\_pid\_d              & Postavlja D član aktivnog PID regulatora     & \texttt{set\_pid\_d(92.2)}                    \\
                set\_pid\_v              & Postavlja V član aktivnog PID regulatora     & \texttt{set\_pid\_v(6.67)}                   \\
                set\_ref\_angle\_z       & Postavlja ref. kut z-osi (stupnjevi)         & \texttt{set\_ref\_angle\_z(30)}               \\
                set\_ref\_angvel\_z      & Postavlja ref. kutnu brzinu z-osi (rad/s)    & \texttt{set\_ref\_angvel\_z(-1.2)}            \\
                set\_rw\_duty\_cycle\_z  & Postavlja Duty cycle zamašnjaka              & \texttt{set\_rw\_duty\_cycle\_z(99)}          \\
                \bottomrule
                \end{tabular}
                \end{table}

                Obratimo pažnju kako svaka komanda, da bi je satelit primio, mora završavati sa ASCII znakom \texttt{\textbackslash n} odnosno novim redom \engl{new line, line feed - LF}. Također, komunikacijska dretva će ignorirati bilo koju drugu komandu koja nije opisana u tablici \ref{tbl:lista_komandi}.

                Svi parametri ADCS sustava koje želimo poslati preko Bluetooth sučelja moraju proći kroz komunikacijsku dretvu. Kako ADCS dretva jedina ima informaciju o npr. trenutnoj orijentaciji, morali smo implementirati način komunikacije između dretvi. Način komunikacije između dretvi implementiran je pomoću tzv. \emph{Message Queue}-a \cite{message_queue}.

                Pseudokod komunikacijske dretve nalazi se u nastavku:

                \begin{lstlisting}[language=C]
inicijaliziraj_bluetooth();

while (True) {
    if (provjeri_ima_li_poruka_za_slanje()) {
        poruka = potraži_poruke_od_drugih_dretvi();
        pošalji_poruku_preko_bluetootha(poruka);
    }

    if (provjeri_ima_li_poruka_od_korisnika()) {
        poruka = potraži_primljenu_poruku();

        komanda, arg = potraži_komandu_i_argument_iz_poruke(poruka);

        for (podržana_komanda : podržane_komande) {
            if (podržana_komanda == komanda) {
                funkcija = potraži_funkciju(komanda);
                funkcija(arg);
            }
        }
    }

    raspusti_dretvu();
}           \end{lstlisting}

                Napominjemo kako funkcije za provjeru poruka za slanje i funkcije provjere primljenih korisničkih poruka nisu blokirajuće. Te funkcije provjeravaju ima li poruka koje se trebaju poslati korisniku ili ima li poruka koje je korisnik poslao sustavu. Na kraju beskonačne petlje nalazi se funkcija koja raspušta izvršavanje dretve i daje procesorsko vrijeme drugim dretvama. Komunikacijska dretva u normalnom stanju čeka poruke za slanje na način da ne oduzima procesorsko vrijeme ostalim dretvama jer je komunikacijska dretva najmanjeg prioriteta - izvršava se odvija jedino onda kada su sve ostale dretve u stanju čekanja. Primanje korisničkih komandi odvija se pomoću UART prekidne rutine gdje na svaki primljeni znak s Bluetooth modula, mikroupravljač odlazi u prekidnu rutinu i puni spremnik znakova koji sadrži sve primljene znakove. Jednom kada komunikacijska dretva dobije procesorsko vrijeme ona će provjeriti ima li primljenih znakova u spremniku znakova i sačinjavaju li oni korisničku komandu. Na temelju toga će komunikacijska dretva ići u daljnju obradu tih komandi. 
            }
        }
    }

    \section{Razvoj}{
        U ovom dijelu će ukratko biti objašnjeno na koji način se razvija programska podrška ADCS sustava. Programska podrška sustava napisana je u C programskom jeziku standarda C99 \cite{c99}. Sva programska logika nalazi se unutar već spomenutog \texttt{src} direktorija, a testovi se razvijaju unutar \texttt{tests} direktorija. 

        Razvoj počinje tzv. kloniranjem projekta koji se nalazi na GitHub repozitoriju \cite{github_repo} pomoću Git programa. Git će klonirati sve datoteke koje se nalaze na repozitoriju i pohraniti ih lokalno na disk razvojne mašine. Napominjemo kako nije nužno klonirati projekt pomoću Git programa već se program može jednostavno preuzeti s GitHub repozitorija i ručno spremiti na disk. Autor preporučuje kloniranje Git-om jer je to jednostavniji postupak.
        
        Napominjemo kako autor programske podrške za razvoj programske podrške koristi \emph{Ubuntu 21.10} operacijski sustav (OS) jer je na tom OS jednostavnije instalirati sve razvojne alate (vidi \texttt{README.md} datoteku za upute). Razvoj je moguć i na Windows OS što je autor također koristio. Instaliranje svih alata za Ubuntu OS moguće je napraviti jednostavnim pokretanjem GNU Make komande \texttt{make install\_deps}.

        Za pomoć pisanju programskog koda autor se odlučio za \emph{VSCode} tekstualni uređivač \cite{vscode}. VSCode pruža mogućnost jednostavnijeg potraživanja programskog koda, bojanje programskih linija i podrške za debugiranje. Napominjemo kako korisnik može koristiti bilo koji drugi tekstualni uređivač.

        Jednom kada smo implementirali željenu funkcionalnost, slijedi postupak prevođenja \engl{compilation}. Za prevođenje koristimo \emph{GNU Arm Embedded Toolchain} prevodilac verzije \emph{v10.3-2021.10} \cite{gnu_arm_toolchain}. Kao graditelj sustava \engl{build system} koristimo \emph{CMake} verzije \emph{v3.18.4} \cite{cmake}. Pomoću CMake-a je moguće jednostavnije postaviti sustav za prevođenje neovisno o tome koju vrstu operacijskog sustava koristimo na razvojnoj mašini (Windows, Ubuntu i sl.). Prilikom prvog prevođenja potrebno je postaviti projekt pomoću Make programa tako što pokrenemo komandu \texttt{make setup\_cmake}. Nakon postavljanja projekta moguće je pokrenuti prevođenje pomoću komande \texttt{make build}, ili kraće \texttt{make}. 

        Za provjeru rada programske podrške (debugiranje), koristimo \emph{OpenOCD} \cite{openocd} program koji u pozadini otvori GDB \cite{gdb} server na kojeg se je moguće spojiti sa VSCode-om. Debugiranje započinjemo unutar VSCode-a tako što otvorimo \emph{Run and Debug} karticu i pokrenemo debugiranje pritiskom na zelenu strelicu. VSCode će pokrenuti prevođenje i pohranu programa na mikroupravljač pod uvjetom da je Nucleo pločica priključena na razvojno računalo pomoću USB kabela. Postavimo li zaustavnu točku \engl{breakpoint} unutar npr. glavne \emph{main} funkcije, program bi morao na trenutak prestati s izvođenjem i korisniku dati pristup vrijednostima svih varijabli koje program koristi unutar \emph{main} funkcije. Pritiskom na tipku nastavi \engl{Continue}, program bi trebao nastaviti s izvođenjem. 

        Ako postupkom debugiranja vidimo neko neželjeno ponašanje programa, debugiranje se može prekinuti i grešku možemo prepraviti. Jednom kada smo prepravili grešku možemo opet na isti način pokrenuti postupak debugiranja.

        Kada smo zadovoljili sve zahtjeve programske podrške, preporučuje se da se programski kod formatira. Formatiranje programskog koda je važno ako isti sustav uređuje više osoba istovremeno. Pretpostaviti je da svaka osoba ima svoj način pisanja programske podrške i zbog toga može doći do otežane čitljivosti koda. Da bi tome pribjegli koristimo \emph{ClangFormat} program za formatiranje programskog koda \cite{clang_format}. Formatiranje programskog koda pokreće se komandom \texttt{make clang\_format}.

        Jednom kada smo uspješno napravili sve postupke, programski kod je moguće verzionirati pomoću Git programa postupkom koji je objašnjen ovdje \cite{git_commit_instrukcije} ili preinake poslati direktno autoru projekta (kontakt se nalazi na GitHub stranici projekta).

        Kao zanimljivost navest ćemo broj linija programskog koda za svaki poddirektorij unutar \texttt{src} direktorija. Broj linija programskog koda nalazi se u tablici \ref{tbl:broj_linija}.

        \begin{table}[htb]
        \caption{Broj linija koda za svaki direktorij unutar \texttt{src} direktorija.}
        \label{tbl:broj_linija}
        \centering
        \begin{tabular}{lll} 
        \toprule
        Direktorij & C99 & Assembly \\ 
        \midrule
        drivers     &     63330    &   0    \\
        libs        &     6776     &   0    \\
        rtos        &     13229    &   0    \\
        middlewares &     1444     &   0    \\
        core        &     633      &   283  \\
        mcu         &     367      &   0    \\
        bsp         &     125      &   0    \\
        utils       &     53       &   0    \\
        top\_dir    &     30       &   0    \\
        \bottomrule
        \end{tabular}
        \end{table}
    }
}

\chapter{Eksperimentalna verifikacija ADCS sustava}{
    U ovom poglavlju objasnit ćemo testni sustav za eksperimentalnu verifikaciju programske podrške i navesti postupke i rezultate eksperimentalne verifikacije. 

    \section{Opis sustava i korištenih alata}{
    \label{section:opis_sustava_i_koristenih_alata}
        Verifikacijski sustav sastoji se od nekoliko dijelova. Prvi i najvažniji dio je tzv. zračni ležaj sa pripadajućom plastičnom kuglom prikazan na slici \ref{fig:fotka_zracni}.

        \begin{figure}[htb]
        \centering
        \includegraphics[width=0.6\textwidth]{images/fotka_zracni.jpg}
        \caption{Prikaz zračnog ležaja sa pripadajućom kuglom.}
        \label{fig:fotka_zracni}
        \end{figure}

        Zračni ležaj sastoji se od 3D isprintane polusferične podloge koja se napaja stlačenim zrakom koji dolazi iz kompresora zraka. Stlačeni zrak dolazi na površinu zračnog ležaja i stvara tanki film zračne struje koja smanjuje trenje između ležaja i plastične kugle. Pomoću zračnog ležaja dobivamo uvjete koji vladaju u orbiti oko Zemlje gdje nema otpora zraka koji bi stvarao parazitni moment na satelit. Plastična kugla sastoji se od vanjske ljuske i plastičnog držača satelita. Plastična vanjska ljuska sastavljena je od dvije polusfere. Plastični držač izrađen je od laserski rezanog plexiglasa i prikazan je na slici \ref{fig:drzac}. Posebnim navojnim odstojnicima satelit je pričvršćen na plastični držač \cite{zracni_lezaj}.

        \begin{figure}[htb]
        \centering
        \includegraphics[width=0.6\textwidth]{images/drzac.png}
        \caption{Prikaz plastičnog držača satelita \cite{zracni_lezaj}.}
        \label{fig:drzac}
        \end{figure}

        Za komuniciranje sa satelitom koristimo računalo ili pametni mobilni telefon koji sadrže Bluetooth sučelje. Za klasično komandno sučelje na Windows računalu koristimo program \emph{Termite} \cite{termite} prikazan na slici \ref{fig:termite}, a na Android mobilnom telefonu aplikaciju \emph{Serial Bluetooth Terminal} \cite{mobilna_app} prikazanu na slici \ref{fig:mobilna_app}.

        \begin{figure}[htb]
        \centering
        \includegraphics[width=0.8\textwidth]{images/termite.png}
        \caption{Prikaz \emph{Termite} aplikacije za pristup COM komandnom sučelju \cite{termite}.}
        \label{fig:termite}
        \end{figure}

        Podešavanje \emph{Termite} programa je vrlo jednostavno. Postupak započinje spajanjem računala i satelita preko Bluetooth sučelja čiji postupak nećemo objašnjavati jer ovisi verziji Windows operacijskog sustava. Nakon što smo se uspješno priključili računalom na Bluetooth satelita, odabiremo pripadajući COM port unutar \emph{Termite} aplikacije. Ako je sve uspješno obavljeno u programu je moguće vidjeti podatke koje dolaze sa satelita u obliku običnog teksta. Jednako tako unutar \emph{Termite} programa moguće je slanje komandi prema satelitu. Važno je napomenuti kako svaka komanda mora završavati sa $'\backslash n'$ znakom što je moguće podesiti kao postavku unutar \emph{Termite} programa. 

        Podešavanje \emph{Serial Bluetooth Terminal} Android mobilne aplikacije i spajanje sa satelitom vrlo je jednostavno i neće biti objašnjeno. Nakon uspješnog spajanja sa satelitom, unutar aplikacije se pojavljuju podaci sa satelita. Slanje komandi prema satelitu jednostavno upisuju u za to predviđeni prozor unutar aplikacije. Napominjemo kako je u postavkama aplikacije potrebno podesiti da svaka komanda završava sa $'\backslash n'$ znakom. 

        \begin{figure}[htb]
        \centering
        \includegraphics[width=0.4\textwidth]{images/mobilna_app.png}
        \caption{Prikaz \emph{Serial Bluetooth Terminal} Android aplikacije \cite{mobilna_app}.}
        \label{fig:mobilna_app}
        \end{figure}

        Želimo li grafički prikazivati vrijednosti koje dolaze sa satelita, to možemo učiniti sa \emph{SerialPlot} programom \cite{serialplot}. \emph{SerialPlot} program pruža različite mogućnosti: primanje i slanje komandi, grafičko prikazivanje vrijednosti, spremanje podataka u CSV datoteku i još mnogo toga. Program je besplatan i otvorenog koda. Sučelje \emph{SerialPlot} programa prikazano je na slici \ref{fig:serialplot}.

        \begin{figure}[htb]
        \centering
        \includegraphics[width=0.8\textwidth]{images/serialplot.png}
        \caption{Prikaz \emph{SerialPlot} aplikacije za grafički prikaz vrijednosti sa COM sučelja \cite{serialplot}.}
        \label{fig:serialplot}
        \end{figure}

        Postupak spajanja \emph{SerialPlot} programa i satelita praktično je isto kao i spajanje sa Termite programom i neće biti ovdje objašnjeno. Prilikom uspješnog spajanja na ekranu se pojavljuju grafičke vrijednosti sa satelita. U programu je moguće odabrati automatsku detekciju broja podataka u ovisnosti o tome na koji način šaljemo vrijednosti. U našem slučaju, vrijednosti šaljemo kao cijele brojeve odvojene znakom zareza ($,$). Takvu postavku moramo odabrati i unutar \emph{SerialPlot} programa. Svaku pojedinačnu krivulju podatka moguće je sakriti ili prikazati odabirom tzv. zelene kvačice unutar programa. 
    }

    \section{Određivanje parametara}{
        \subsection{Pojednostavljeni model satelita}{
        \label{subsection:kinematicki_model}
            Kao što smo već pisali u poglavlju \ref{section:pojednostavljeni_model_satelita}, pojednostavljeni kinematički model satelita (jednadžba \ref{eq:laplace_prvi_red}) definirali smo kao:

            \begin{equation}
                H(s) = \frac{Y(s)}{X(s)} = K \frac{1/\tau}{s + 1/\tau},
            \end{equation}

            gdje su parametri $K$ i $\tau$ nepoznanice koje je potrebno odrediti. 

            Postupak određivanja parametara započinje pokretanjem ADCS sustava. Nakon što se ADCS sustav pokrenuo i kada je uspješno prošla sva inicijalizacija, satelit postavljamo na zračni ležaj tako da satelit u potpunosti miruje. Nakon što smo uspostavili sve uvjete za testiranje, možemo krenuti dalje na snimanje odziva sustava na tzv. Step pobudu.

            Snimanje sustava na Step pobudu započinje pokretanjem programa \emph{SerialPlot} (vidi poglavlje \ref{section:opis_sustava_i_koristenih_alata}) pomoću kojeg je vrlo lako moguće snimiti sve vrijednosti u CSV format datoteke. Snimljene vrijednosti zatim je lako analizirati pomoću matematičkih alata kao što je MATLAB. Prilikom pokretanja \emph{SerialPlot} programa odaberemo COM port na kojemu je moguće dobiti podatke iz satelita. Namjestimo li automatsko primanje svih parametara na ekranu ćemo vidjeti 3 vrste signala: estimirani Eulerovi kutovi, mjerenje sa žiroskopa i Duty Cycle zamašnjaka. Pomoću mjerenja žiroskopa i vrijednosti DC zamašnjaka moguće je odrediti kinematički model satelita. U jednadžbi \ref{eq:laplace_prvi_red} kao ulazni parametar sustava $X(s)$ imamo DC zamašnjaka, a kao izlaz $Y(s)$ kutnu brzinu satelita. 

            Odziv sustava na dvije Step pobude prikazan je na slici \ref{fig:step_response}. Oko 7. sekunde poslali smo satelitu naredbu da zavrti zamašnjak sa 0\% na 50\% DC nakon koje kutna brzina počinje naglo rast do nekih 3 rad/s. Primijetimo kako oko 20. sekunde kutna brzina počinje blago padati. Razlog tomu su blage nepravilnosti zračnog ležaja koje uzrokuju parazitni moment koji usporava satelit. Modeliranje parazitnog momenta nismo uzimali u obzir radi jednostavnosti jednadžbi. Postupak snimanja Step pobude napravili smo još jednom od 60. do 85. sekunde.

            \begin{figure}[htb]
            \centering
            \includegraphics[width=1.0\textwidth]{other/step_response.png}
            \caption{Odzivi sustava na Step pobudu sa DC zamašnjaka na 50\%.}
            \label{fig:step_response}
            \end{figure}

            Step funkciju (pobudu) u Laplaceovoj domeni zapisujemo kao:

            \begin{equation}
            \label{eq:step}
                S(s) = \frac{1}{s}.
            \end{equation}

            Koristeći jednadžbu \ref{eq:laplace_prvi_red} i jednadžbu \ref{eq:step}, odziv na Step pobudu satelita u Laplaceovoj domeni možemo zapisati kao:

            \begin{equation}
                Y(s) = H(s)X(s) = K \frac{1/\tau}{s + 1/\tau} \; \frac{1}{s},
            \end{equation}

            ili u vremenskoj kao domeni:

            \begin{equation}
                y(t) = (h \ast x)(t) = K (1 - e^{-\frac{t}{\tau}}),
            \end{equation}

            Parametar $K$ označuje koeficijent pretvorbe između DC zamašnjaka i izlazne kutne brzine. Parametar $\tau$ označava koeficijent tromosti sustava: što je sustav tromiji to je parametar $\tau$ veći, i obratno.

            Pomoću MATLAB alata i pripadajućih MATLAB skripti koje je moguće pronaći unutar \texttt{docs/step\_response} direktorija \cite{link_na_fit}, moguće je na jednostavan način dobiti $K$ i $\tau$ parametre kinematičkog modela. Primjer dobivanja parametara preko MATLAB skripti moguće je vidjeti na slici \ref{fig:fittana_funkcija}. Napisana skripta prvo učitava već snimljene podatke (vidi sliku \ref{fig:step_response}) i izlučuje trenutak eksponencijalnog rasta kutne brzine. Na temelju tog vremenskog odsječka skripta će kao rezultat dati $K$ i $\tau$ koeficijente. 

            \begin{figure}[htb]
            \centering
            \includegraphics[width=1.0\textwidth]{other/fittana_funkcija.png}
            \caption{Graf odziva na Step i graf funkcije kojoj smo pronašli nepoznate parametre.}
            \label{fig:fittana_funkcija}
            \end{figure}

            Spomenute MATLAB skripte, osim estimacije parametara kao rezultat daju i kinematičke modele. Prvi kinematički model odnosi se na modeliranje kutne brzine (vidi jednadžbu \ref{eq:laplace_prvi_red}), a drugi na modeliranje orijentacije/kuta (jednadžba \ref{eq:laplace_drugi_red}). Pomoću tih modela nalazimo parametre PID regulatora (vidi sljedeće poglavlje).
        }

        \subsection{PID regulator}{
        \label{subsection:pid_regulator}

            % TODO DODAJ KOJE SMO PARAMETRE DOBILI NA KRAJU ZA OBJE REG PETLJE
            % TODO PUSTI ME KROZ ISPRAVI ME

            \subsubsection{Regulator kutne brzine}{
                Pomoću spomenuta dva modela možemo eksperimentalno odrediti koeficijente PID regulatora. Otvorimo \emph{PID Tuner} MATLAB aplikaciju \cite{pid_tuner} u kojemu prvo unosimo prvi kinematički model - model kutne brzine satelita. Podešavanjem kliznika na vrhu prozora moguće je PID regulator ugoditi na željeni odziv u ovisnosti o tome želimo li brži odziv s relativno velikim izdizanjem \engl{overshoot} ili sporiji odziv sa blažim izdizanjem. U drugom prozoru moguće je otvoriti graf na kojemu je prikazan izlaz regulatora \engl{controller effort}. Pomoću takvog grafa možemo provjeriti da nam izlaz iz regulatora ne prelazi DC zamašnjaka jer se u programski izlaz regulatora ograničava na 100\% DC zamašnjaka što nam uvodi nelinearnosti u sustav. 
            }

            \subsubsection{Regulator orijentacije}{
                Jednaki postupak određivanja koeficijenata PID regulatora vrijedi i za regulaciju orijentacije, odnosno kuta. Skripta će na izlazu, osim modela kutne brzine, dati i model orijentacije. Taj model možemo također učitati u \emph{PID Tuner} aplikaciju i po potrebi ugoditi koeficijente PID regulatora.
            }
        }
    }

    \section{Rezultati verifikacije}{
        Rezultate parametrizacije PID regulatora snimili smo prilikom eksperimentalne verifikacije sustava. Na slici \ref{fig:ang_vel_reg_user} prikazan je odziv sustava na promjenu željene kutne brzine u nekoliko navrata. U prvom navratu korisnik je u 5. sekundi komandom zadao željenu kutnu brzinu od 1 rad/s. Možemo vidjeti kako kutna brzina naglo počinje rasti sve dok satelit ne dosegne željenu brzinu od 1 rad/s oko 20. sekunde. Neposredno nakon toga satelitu je poslana naredba za referentnu brzinu od 0 rad/s i to se može jasno vidjeti naglim ali kontroliranim padom do 0 rad/s. Jednaki postupak izveli smo u 55. sekundi gdje smo satelitu zadali kutnu brzinu od 1 rad/s ali sada u suprotnom smjeru. Žuto obojana linija na grafu predstavlja vrijednosti izlaza regulatora. Izlaz regulatora direktno utječe na DC zamašnjaka. Negativna vrijednost označava suprotni smjer vrtnje zamašnjaka. Primijetimo kako graf izlaza regulatora ne prelazi $\pm$100\%. Primijetimo još i činjenicu kako oko 30. i 85. sekunde postoji blago nadvišenje s obzirom na referentnu kutnu brzinu koje traje relativno dugo. Uzrok tog nadvišenja je mala greška referentne i željene kutne brzine koja dolazi na ulaz PID regulatora. PID regulator množi tu malu grešku sa K članom ali to i dalje nije dovoljno za značajniju korekciju. O utjecaju D člana nema govora jer je sustav u stacionarnom stanju i ne postoje visokofrekventne komponente na koje bi D član reagirao. Primijetimo kako je izlaz PID regulatora u početku relativno mali i da s vremenom raste. To je upravo utjecaj I člana koji s vremenom integrira malu grešku i koji će nakon dovoljno vremena postati toliko značajan da će vršiti korekciju kutne brzine. 

        \begin{figure}[htb]
        \centering
        \includegraphics[width=1.0\textwidth]{other/ang_vel_reg_user.png}
        \caption{Odzivi sustava na promjenu referentne kutne brzine.}
        \label{fig:ang_vel_reg_user}
        \end{figure}

        Na drugoj slici \ref{fig:ang_vel_reg_dist} vidimo odziv regulatora na vanjske smetnje gdje smo u nekoliko navrata ručno pomaknuli satelit i tako mu doveli vanjsku smetnju. Dva su trenutka smetnje: prvi oko 10. sekunde i drugi oko 32. sekunde. Prva smetnja ima različitu orijentaciju u odnosu na drugu zbog simetričnosti regulacije. Vidimo kako je referentna kutna brzina cijelo vrijeme postavljena u 0 rad/s. Primijetimo kako regulator vrlo brzo vrši korekciju i da je tranzijentno vrijeme vrlo kratko. Zanimljivo je još jednom primijetiti manifestacije nepravilnosti zračnog ležaja. Vidljivo je na samom početku grafa da izlaz regulatora nije 0\% nego ima neku određenu vrijednost. To se događa zato što zračni ležaj daje konstantni moment kojeg regulator pokušava kompenzirati. Uočimo kako oko 40. sekunde postoji znatno nadvišenje kutne brzine što je u svakom slučaju negativna pojava. Daljnja eksperimentalna verifikacija mogla bi ukazati postojanje boljih parametara PID regulatora koji bi dali bolju regulacijsko ponašanje.

        \begin{figure}[htb]
        \centering
        \includegraphics[width=1.0\textwidth]{other/ang_vel_reg_dist.png}
        \caption{Odzivi sustava na vanjsku smetnju kutne brzine.}
        \label{fig:ang_vel_reg_dist}
        \end{figure}

        Nadalje, rezultate ugađanja PID regulatora za regulaciju kuta možemo vidjeti na slici \ref{fig:angle_reg_user} gdje je korisnik u 3. sekundi zadao referentni kut od 90 stupnjeva. Vidimo kako od tog trenutka imamo nagli skok iz estimiranog kuta do 90 stupnjeva u 16. sekundi. Nakon toga korisnik zadaje naredbu za referentnu orijentaciju od -90 stupnjeva. Primijetimo kako orijentacija počinje naglo padati i prelazi u drugu stranu. Na grafu je vidljivo kako postoji relativno veliko nadvišenje. Uzrok tog nadvišenja je u početku relativno velika izlazna komponenta PID regulatora gdje PID regulator zamašnjaku zadaje naredbu brzine vrtnje od 1500\% DC-a. To je naravno nemoguće jer DC zamašnjaka može maksimalno biti 100\%. Razlog toliko velikog izlaza leži u relativno velikom D članu koji zapravo i mora biti velik jer mora kompenzirati veliku integralnu komponentu kinematičkog modela za orijentaciju satelita (jednadžba \ref{eq:laplace_drugi_red}). Bez obzira što regulator traži od zamašnjaka da se zavrti nemogućim brzinama, sustav je tako razvijen da će \emph{odrezati} \engl{clamp} vrijednosti više/niže od $\pm$100\% DC zamašnjaka. Na grafu je vidljivo kako regulatoru treba relativno dugo vrijeme kompenzacije greške. Razlog tomu je što su K i P komponente relativno malog iznosa te mora proći neko vrijeme sve dok I komponenta PID regulatora ne postane dovoljno velika kako bi kompenzirala nadvišenje. Tijekom  verifikacije testirali smo različite kombinacije PID parametara no ni jedna nije rezultirala zadovoljavajućim rezultatima. Pretpostavljamo kako se sustavi 2. reda, kao što je sustav modela orijentacije satelita, teško reguliraju konvencionalnim PID regulatorom kojeg koristimo, već se rabe neke druge vrste regulatora prikladnijim za sustave 2. reda \cite{reg_2_red}. 

        \begin{figure}[htb]
        \centering
        \includegraphics[width=1.0\textwidth]{other/angle_reg_user.png}
        \caption{Odzivi sustava na promjenu referentnog Eulerovog kuta.}
        \label{fig:angle_reg_user}
        \end{figure}

        Na slici \ref{fig:angle_reg_dist} možemo vidjeti odziv regulatora na vanjske smetnje gdje smo ručno sustav pomaknuli iz referentnog položaja. Prvi put u 5. sekundi pomaknuli smo sustav za otprilike -20 stupnjeva. Zbog visokofrekventne komponente smetnje, D član u početku prevladava sve dok I član s vremenom ne postane dominantniji. Drugu vanjsku smetnju generirali smo u 42. sekundi gdje smo satelit ručno pomakli za oko 57 stupnjeva. Regulator je kompenzirao grešku za oko 50 sekundi. I ovdje je jasno vidljiv negativan utjecaj nepravilnosti zračnog ležaja. 

        \begin{figure}[htb]
        \centering
        \includegraphics[width=1.0\textwidth]{other/angle_reg_dist.png}
        \caption{Odzivi sustava na vanjsku smetnju Eulerovog kuta.}
        \label{fig:angle_reg_dist}
        \end{figure}
    }
}

\chapter{Zaključak}{
    U radu smo prezentirali programsku podršku sustava za određivanje i kontrolu orijentacije satelita (ADCS). Definirali smo jednadžbe za reprezentaciju orijentacije i kutnog gibanja satelita. Naveli smo najčešće korištene orijentacijske senzore i aktuatore te objasnili njihov način rada. Predstavili smo razvijeno sklopovlje sustava i izabrane senzore i aktuatore. Objasnili smo organizaciju programske podrške, korištene biblioteke, način rada i naveli razvojne alate. Opisali smo glavne dijelove i način rada sustava za eksperimentalnu verifikaciju te komentirali rezultate verifikacije.
}

\bibliographystyle{templates/template}
\bibliography{literatura}

\begin{sazetak}{
    Precizna orijentacija satelita preduvjet je za uspješnu provedbu misije, stoga je sustav za određivanje i kontrolu orijentacije (ADCS) jedan od najvažnijih sustava satelita. U ovom radu prezentirana je programska podrška ADCS sustava koja omogućuje: sakupljanje i obradu podataka iz orijentacijskih senzora, određivanje orijentacije, upravljanje aktuatorima te održavanje željene orijentacije. Na kraju rada prezentirani su i komentirani rezultati eksperimentalne verifikacije sustava. 
}

\kljucnerijeci{
    Orijentacija satelita; estimacija orijentacije; kontrola orijentacije; ADCS; Cubesat
}
\end{sazetak}

\engtitle{Software for Satellite Attitude Determination and Control System}
\begin{abstract}{
    Accurate satellite orientation is a prerequisite for a successful mission, therefore the Attitude Determination and Control System (ADCS) is one of the most important satellite systems. In this paper, the ADCS system software is presented, which enables the collection and processing of the orientation sensors data, attitude determination, actuator control and finally, control of the desired orientation. In the end, ADCS experimental verification results are presented.
}

\keywords{
    Satellite orientation; orientation estimation; orientation control; ADCS; Cubesat
}
\end{abstract}

\end{document}
